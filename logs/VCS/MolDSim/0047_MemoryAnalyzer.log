---------------------------------------------------------------------
INFERRING...
Name: x269
Type: StreamOut[BurstCmd]
Src:  ProjectTemplate.scala:21:14
Src:        A_sram load A_dram
Symbol:     x269 = StreamOutNew(BurstCmdBus)
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 0 Reads: 

  <No Read Groups>
  Grouping 1 Writes: 
    Access: x289 {0} [x292 (stage: -1)]
  1 Write Groups:
  Group #0
    x289 = StreamOutWrite(x269,x287,Set(x288)) wr{0}
     b247     c   mod
        1     0     0wr
  x289 <-> x289: LCA: x292 (stage: -1), coarse-dist: <None>
Dephasing Iters: x289 = StreamOutWrite(x269,x287,Set(x288)) wr{0}
 b247     c   mod
    1     0     0wr -> x292
Leaf: x292, Iters: ListBuffer(b247), target: x292, elements: ListBuffer(b247)
Leaf: x292, Iters: ListBuffer(b247), target: x292, elements: List(0)
Leaf: x292, Iters: ListBuffer(b247), target: x292, elements: List(0)
General write dephasing rules for x269: (b247,List(0)) -> (b247,0)
solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
x292: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
  x289: StreamOutWrite
**************************************************************************************
Analyzing costs for banking schemes found for x269
Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
  - 0 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
          Access Hist:
          | width | R | W |
          | 1 | 0 | 1 |
        - Duplicate costs 0.0 (LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
***** Cost summary *****
Cost: 0.0 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
**************************************************************************************
  Reads:
  Writes:
    grp 0: x289 = StreamOutWrite(x269,x287,Set(x288)) wr{0}
    grp 0:  b247     c   mod
    grp 0:     1     0     0wr
  Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x289 = StreamOutWrite(x269,x287,Set(x288)) {0}
      - ProjectTemplate.scala:21:14: A_sram load A_dram
      - Scope: x292 (scope: 0, 0)
0 [Type:RD]:))
---------------------------------------------------------------------
SUMMARY: 
Name: x269
Type: StreamOut[BurstCmd]
Src:  ProjectTemplate.scala:21:14
Src:        A_sram load A_dram
Symbol:     x269 = StreamOutNew(BurstCmdBus)
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x289 = StreamOutWrite(x269,x287,Set(x288)) {0}
        - ProjectTemplate.scala:21:14: A_sram load A_dram
        - Scope: x292 (scope: 0, 0)
  0 [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x289 {0}
  Added dispatch 0 to x289 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x289 {0}
  Added dispatch 0 to x289 {0}
---------------------------------------------------------------------
INFERRING...
Name: x404
Type: Reg[Fix[TRUE,_32,_0]]
Src:  ProjectTemplate.scala:54:16
Src:        out_host store out_sram
Symbol:     x404 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x425 {} [x437 (stage: -1)]
  1 Read Groups:
  Group #0
    x425 = RegRead(x404) rd{}
       c  modrd
  Grouping 1 Writes: 
    Access: x423 {} [x424 (stage: -1)]
  1 Write Groups:
  Group #0
    x423 = RegWrite(x404,x413,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x425 {}: 
      x423 {}
    x425 <-> x423: LCA: x438 (stage: -1), coarse-dist: <None>
    x423 <-> x423: LCA: x424 (stage: -1), coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x425 = RegRead(x404) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x438: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
    x424: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x423: RegWrite
    x437: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x425: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x404
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x425 = RegRead(x404) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x423 = RegWrite(x404,x413,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x423 = RegWrite(x404,x413,Set()) {}
      - ProjectTemplate.scala:54:16: out_host store out_sram
      - Scope: x424 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x425 = RegRead(x404) {}
      - ProjectTemplate.scala:54:16: out_host store out_sram
      - Scope: x437 (scope: -1, -1)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x404
Type: Reg[Fix[TRUE,_32,_0]]
Src:  ProjectTemplate.scala:54:16
Src:        out_host store out_sram
Symbol:     x404 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x423 = RegWrite(x404,x413,Set()) {}
        - ProjectTemplate.scala:54:16: out_host store out_sram
        - Scope: x424 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x425 = RegRead(x404) {}
        - ProjectTemplate.scala:54:16: out_host store out_sram
        - Scope: x437 (scope: -1, -1)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x425 {}
  Added dispatch 0 to x425 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x423 {}
  Added dispatch 0 to x423 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x425 {}
  Added dispatch 0 to x425 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x423 {}
  Added dispatch 0 to x423 {}
---------------------------------------------------------------------
INFERRING...
Name: out_sram (x321)
Type: SRAM2[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:23:29
Src:        val out_sram = SRAM[T](N,3)
Symbol:     x321 = SRAMNew(List(Const(100), Const(3)),SRAM2[Fix[TRUE,_10,_22]])
Effort:    1
BankingViews:   List(Flat(2), Hierarchical(2,None))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()), RegroupDims(List(0)), RegroupDims(List(1)), RegroupDims(List(0, 1)))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x434 {0,0} [x437 (stage: -1)]
  1 Read Groups:
  Group #0
    x434 = SRAMRead(x321,List(b256, x433),Set(x432)) rd{0,0}
     b256  b195  b461     c   mod
        1     0     0     0     0
       -3     1    16     0     0rd
  Grouping 10 Writes: 
    Access: x394 {0,0} [x395 (stage: -1)]
    Access: x394 {1,0} [x395 (stage: -1)]
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{1,0}
 b20  b81    c  mod
  10    0    1    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <1 accesses>
    Access: x394 {2,0} [x395 (stage: -1)]
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{2,0}
 b20  b81    c  mod
  10    0    2    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{2,0}
 b20  b81    c  mod
  10    0    2    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <2 accesses>
    Access: x394 {3,0} [x395 (stage: -1)]
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{3,0}
 b20  b81    c  mod
  10    0    3    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{3,0}
 b20  b81    c  mod
  10    0    3    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{3,0}
 b20  b81    c  mod
  10    0    3    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <3 accesses>
    Access: x394 {4,0} [x395 (stage: -1)]
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <4 accesses>
    Access: x394 {5,0} [x395 (stage: -1)]
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <5 accesses>
    Access: x394 {6,0} [x395 (stage: -1)]
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <6 accesses>
    Access: x394 {7,0} [x395 (stage: -1)]
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <7 accesses>
    Access: x394 {8,0} [x395 (stage: -1)]
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <8 accesses>
    Access: x394 {9,0} [x395 (stage: -1)]
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Computing overlaps: x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set())) - x394 = Some(SRAMWrite(x321,x393,List(b20, b81),Set()))
Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0wr -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <9 accesses>
  1 Write Groups:
  Group #0
    x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{0,0}
     b20  b81    c  mod
      10    0    0    0
       0    1    0    0wr
    x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{1,0}
     b20  b81    c  mod
      10    0    1    0
       0    1    0    0wr
    x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{6,0}
     b20  b81    c  mod
      10    0    6    0
       0    1    0    0wr
    x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{3,0}
     b20  b81    c  mod
      10    0    3    0
       0    1    0    0wr
    x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{5,0}
     b20  b81    c  mod
      10    0    5    0
       0    1    0    0wr
    x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{4,0}
     b20  b81    c  mod
      10    0    4    0
       0    1    0    0wr
    x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{2,0}
     b20  b81    c  mod
      10    0    2    0
       0    1    0    0wr
    x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{9,0}
     b20  b81    c  mod
      10    0    9    0
       0    1    0    0wr
    x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{7,0}
     b20  b81    c  mod
      10    0    7    0
       0    1    0    0wr
    x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{8,0}
     b20  b81    c  mod
      10    0    8    0
       0    1    0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x434 {0,0}: 
      x394 {0,0}
      x394 {1,0}
      x394 {6,0}
      x394 {3,0}
      x394 {5,0}
      x394 {4,0}
      x394 {2,0}
      x394 {9,0}
      x394 {7,0}
      x394 {8,0}
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
  Mustfollow: x394 -> x394 -> x434 [true]
    CtrlA: x444 (stage: -1) [1]
    CtrlB: x444 (stage: -1) [1]
    IsStream: false
    ctrlAB: x395 (stage: -1)
    x434 <-> x394: LCA: x444 (stage: -1), coarse-dist: <None>
    x394 <-> x394: LCA: x395 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x434 = SRAMRead(x321,List(b256, x433),Set(x432)) rd{0,0}
 b256  b195  b461     c   mod
    1     0     0     0     0
   -3     1    16     0     0rd -> x437
  Leaf: x437, Iters: ListBuffer(b256, b195), target: x442, elements: ListBuffer(b256, b195)
  Leaf: x437, Iters: ListBuffer(b256, b195), target: x442, elements: List(0, 0)
  Leaf: x437, Iters: ListBuffer(b256, b195), target: x442, elements: List(0, 0)
  General read dephasing rules for x321: (b256,List(0, 0)) -> (b256,0)
  - (b195,List(0, 0)) -> (b195,0)
  Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{0,0}
 b20  b81    c  mod
  10    0    0    0
   0    1    0    0wr -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{1,0}
 b20  b81    c  mod
  10    0    1    0
   0    1    0    0wr -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0wr -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{3,0}
 b20  b81    c  mod
  10    0    3    0
   0    1    0    0wr -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0wr -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0wr -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{2,0}
 b20  b81    c  mod
  10    0    2    0
   0    1    0    0wr -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0wr -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0wr -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0wr -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  General write dephasing rules for x321: (b81,List(7, 0)) -> (b81,0)
  - (b81,List(2, 0)) -> (b81,0)
  - (b20,List(6, 0)) -> (b20,0)
  - (b81,List(0, 0)) -> (b81,0)
  - (b20,List(3, 0)) -> (b20,0)
  - (b20,List(4, 0)) -> (b20,0)
  - (b20,List(7, 0)) -> (b20,0)
  - (b81,List(6, 0)) -> (b81,0)
  - (b20,List(0, 0)) -> (b20,0)
  - (b81,List(4, 0)) -> (b81,0)
  - (b20,List(2, 0)) -> (b20,0)
  - (b81,List(1, 0)) -> (b81,0)
  - (b81,List(3, 0)) -> (b81,0)
  - (b81,List(5, 0)) -> (b81,0)
  - (b20,List(1, 0)) -> (b20,0)
  - (b20,List(8, 0)) -> (b20,0)
  - (b81,List(8, 0)) -> (b81,0)
  - (b20,List(9, 0)) -> (b20,0)
  - (b20,List(5, 0)) -> (b20,0)
  - (b81,List(9, 0)) -> (b81,0)
  Finding scheme for BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Original banking group #0 has (10 accesses)
       b20    c  mod
        10    8    0wr
       b20    c  mod
        10    6    0wr
       b20    c  mod
        10    3    0wr
       b20    c  mod
        10    2    0wr
       b20    c  mod
        10    4    0wr
       b20    c  mod
        10    0    0wr
       b20    c  mod
        10    9    0wr
       b20    c  mod
        10    1    0wr
       b20    c  mod
        10    7    0wr
       b20    c  mod
        10    5    0wr
  Original banking group #1 has (1 accesses)
       b256     c   mod
          1     0     0rd
  Regrouped banking group #0 has (10 accesses)
       b20    c  mod
        10    8    0wr
       b20    c  mod
        10    6    0wr
       b20    c  mod
        10    3    0wr
       b20    c  mod
        10    2    0wr
       b20    c  mod
        10    4    0wr
       b20    c  mod
        10    0    0wr
       b20    c  mod
        10    9    0wr
       b20    c  mod
        10    1    0wr
       b20    c  mod
        10    7    0wr
       b20    c  mod
        10    5    0wr
  Regrouped banking group #1 has (1 accesses)
       b256     c   mod
          1     0     0rd
   Solution space: 11 * 16 * 11 (B), check complexity: 46
       Checking N=10 and alpha=List(0)
       Checking N=10 and alpha=List(1)
       Success on N=10, alpha=List(1), B=1
       Checking N=10 and alpha=List(2)
       Checking N=10 and alpha=List(3)
       Success on N=10, alpha=List(3), B=1
         x321: Found 2 solutions after 184 (= 4 * 46) attempts to find solution for NBestGuess AlphaBestGuess List(0)
  Original banking group #0 has (1 accesses)
       b81    c  mod
         1    0    0wr
  Original banking group #1 has (1 accesses)
       b256  b195  b461     c   mod
         -3     1    16     0     0rd
  Regrouped banking group #0 has (1 accesses)
       b81    c  mod
         1    0    0wr
  Regrouped banking group #1 has (1 accesses)
       b256  b195  b461     c   mod
         -3     1    16     0     0rd
  Banking scheme List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List()) to 1 
  Banking scheme List(Dims {0}: Cyclic: N=10, B=1, alpha=<3>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List()) to 2 
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(1)))
  Finding scheme for BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Original banking group #0 has (10 accesses)
       b20    c  mod
        10    8    0wr
       b20    c  mod
        10    6    0wr
       b20    c  mod
        10    3    0wr
       b20    c  mod
        10    2    0wr
       b20    c  mod
        10    4    0wr
       b20    c  mod
        10    0    0wr
       b20    c  mod
        10    9    0wr
       b20    c  mod
        10    1    0wr
       b20    c  mod
        10    7    0wr
       b20    c  mod
        10    5    0wr
  Regrouped banking group #0 has (10 accesses)
       b20    c  mod
        10    8    0wr
       b20    c  mod
        10    6    0wr
       b20    c  mod
        10    3    0wr
       b20    c  mod
        10    2    0wr
       b20    c  mod
        10    4    0wr
       b20    c  mod
        10    0    0wr
       b20    c  mod
        10    9    0wr
       b20    c  mod
        10    1    0wr
       b20    c  mod
        10    7    0wr
       b20    c  mod
        10    5    0wr
   Solution space: 11 * 16 * 11 (B), check complexity: 45
       Checking N=10 and alpha=List(0)
       Checking N=10 and alpha=List(1)
       Success on N=10, alpha=List(1), B=1
       Checking N=10 and alpha=List(2)
       Checking N=10 and alpha=List(3)
       Success on N=10, alpha=List(3), B=1
         x321: Found 2 solutions after 180 (= 4 * 45) attempts to find solution for NBestGuess AlphaBestGuess List(0)
  Original banking group #0 has (1 accesses)
       b81    c  mod
         1    0    0wr
  Regrouped banking group #0 has (1 accesses)
       b81    c  mod
         1    0    0wr
  Banking scheme List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 45 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 1 
  Banking scheme List(Dims {0}: Cyclic: N=10, B=1, alpha=<3>, P=<10> (176 solutions, 45 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 2 
  Finding scheme for BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Original banking group #0 has (10 accesses)
       b20  b81    c  mod
        10    0    5    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    7    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    2    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    8    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    4    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    6    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    9    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    1    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    0    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    3    0
         0    1    0    0wr
  Original banking group #1 has (1 accesses)
       b256  b195  b461     c   mod
          1     0     0     0     0
         -3     1    16     0     0rd
  Regrouped banking group #0 has (10 accesses)
       b20  b81    c  mod
        10    0    5    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    7    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    2    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    8    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    4    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    6    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    9    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    1    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    0    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    3    0
         0    1    0    0wr
  Regrouped banking group #1 has (1 accesses)
       b256  b195  b461     c   mod
          1     0     0     0     0
         -3     1    16     0     0rd
   Solution space: 66 * 28 * 11 (B), check complexity: 46
       Checking N=10 and alpha=List(0, 0)
       Checking N=10 and alpha=List(0, 1)
       Checking N=10 and alpha=List(1, 0)
       Success on N=10, alpha=List(1, 0), B=1
       Checking N=10 and alpha=List(1, 1)
       Success on N=10, alpha=List(1, 1), B=1
         x321: Found 2 solutions after 184 (= 4 * 46) attempts to find solution for NBestGuess AlphaBestGuess List(0, 1)
  Banking scheme List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,0>, P=<10,1> (1848 solutions, 46 checks)) accepted!
  incrementing Flat(2), RegroupDims(List()) to 1 
  Banking scheme List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<1,10> (1848 solutions, 46 checks)) accepted!
  incrementing Flat(2), RegroupDims(List()) to 2 
  Banking scheme List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<10,1> (1848 solutions, 46 checks)) accepted!
  incrementing Flat(2), RegroupDims(List()) to 3 
  Finding scheme for BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Original banking group #0 has (10 accesses)
       b20  b81    c  mod
        10    0    5    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    7    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    2    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    8    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    4    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    6    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    9    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    1    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    0    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    3    0
         0    1    0    0wr
  Regrouped banking group #0 has (10 accesses)
       b20  b81    c  mod
        10    0    5    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    7    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    2    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    8    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    4    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    6    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    9    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    1    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    0    0
         0    1    0    0wr
       b20  b81    c  mod
        10    0    3    0
         0    1    0    0wr
   Solution space: 66 * 28 * 11 (B), check complexity: 45
       Checking N=10 and alpha=List(0, 0)
       Checking N=10 and alpha=List(0, 1)
       Checking N=10 and alpha=List(1, 0)
       Success on N=10, alpha=List(1, 0), B=1
       Checking N=10 and alpha=List(1, 1)
       Success on N=10, alpha=List(1, 1), B=1
         x321: Found 2 solutions after 180 (= 4 * 45) attempts to find solution for NBestGuess AlphaBestGuess List(0, 1)
  Banking scheme List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,0>, P=<10,1> (1848 solutions, 45 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 1 
  Banking scheme List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<1,10> (1848 solutions, 45 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 2 
  Banking scheme List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<10,1> (1848 solutions, 45 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 3 
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List(1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List(1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List(1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NBestGuess,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NBestGuess,AlphaRelaxed,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaBestGuess,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaBestGuess,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaRelaxed,RegroupDims(List(0, 1)))
  solution bankings are Map(BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x434 = SRAMRead(x321,List(b256, x433),Set(x432)) rd{0,0}
 b256  b195  b461     c   mod
    1     0     0     0     0
   -3     1    16     0     0rd)) -> List(List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)), List(Dims {0}: Cyclic: N=10, B=1, alpha=<3>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))), BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) -> Map(Set(Set(x434 = SRAMRead(x321,List(b256, x433),Set(x432)) rd{0,0}
 b256  b195  b461     c   mod
    1     0     0     0     0
   -3     1    16     0     0rd)) -> List(List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 45 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)), List(Dims {0}: Cyclic: N=10, B=1, alpha=<3>, P=<10> (176 solutions, 45 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))), BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x434 = SRAMRead(x321,List(b256, x433),Set(x432)) rd{0,0}
 b256  b195  b461     c   mod
    1     0     0     0     0
   -3     1    16     0     0rd)) -> List(List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,0>, P=<10,1> (1848 solutions, 46 checks)), List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<1,10> (1848 solutions, 46 checks)), List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<10,1> (1848 solutions, 46 checks)))), BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) -> Map(Set(Set(x434 = SRAMRead(x321,List(b256, x433),Set(x432)) rd{0,0}
 b256  b195  b461     c   mod
    1     0     0     0     0
   -3     1    16     0     0rd)) -> List(List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,0>, P=<10,1> (1848 solutions, 45 checks)), List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<1,10> (1848 solutions, 45 checks)), List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<10,1> (1848 solutions, 45 checks)))))
  x444: AccelScope (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
    x396: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x395: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
        x394: SRAMWrite
    x443: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
      x442: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x438: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
          x437: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
            x434: SRAMRead
  **************************************************************************************
  Analyzing costs for banking schemes found for out_sram (x321)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 0 | 10 |
            | 10 | 1 | 0 |
          - Duplicate costs 271.74634863019617 (SRAM LUTs: 3.526315789473684%, FFs: 0.2200328407224959%, BRAMs: 268.0%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 1 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=10, B=1, alpha=<3>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 0 | 10 |
            | 10 | 1 | 0 |
          - Duplicate costs 273.09832051392846 (SRAM LUTs: 3.543859649122807%, FFs: 0.22112753147235906%, BRAMs: 269.3333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 45 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 0 | 10 |
            | 10 | 1 | 0 |
          - Duplicate costs 271.74634863019617 (SRAM LUTs: 3.526315789473684%, FFs: 0.2200328407224959%, BRAMs: 268.0%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 1 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=10, B=1, alpha=<3>, P=<10> (176 solutions, 45 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 0 | 10 |
            | 10 | 1 | 0 |
          - Duplicate costs 273.09832051392846 (SRAM LUTs: 3.543859649122807%, FFs: 0.22112753147235906%, BRAMs: 269.3333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,0>, P=<10,1> (1848 solutions, 46 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 0 | 10 |
            | 10 | 1 | 0 |
          - Duplicate costs 271.74634863019617 (SRAM LUTs: 3.526315789473684%, FFs: 0.2200328407224959%, BRAMs: 268.0%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 1 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<1,10> (1848 solutions, 46 checks)))
            Access Hist:
            | width | R | W |
            | 10 | 1 | 10 |
          - Duplicate costs 1811.642324201308 (SRAM LUTs: 23.50877192982456%, FFs: 1.4668856048166392%, BRAMs: 1786.6666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 2 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<10,1> (1848 solutions, 46 checks)))
            Access Hist:
            | width | R | W |
            | 10 | 1 | 10 |
          - Duplicate costs 1668.7839618202595 (SRAM LUTs: 21.65497076023392%, FFs: 1.351213282247765%, BRAMs: 1645.7777777777778%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,0>, P=<10,1> (1848 solutions, 45 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 0 | 10 |
            | 10 | 1 | 0 |
          - Duplicate costs 271.74634863019617 (SRAM LUTs: 3.526315789473684%, FFs: 0.2200328407224959%, BRAMs: 268.0%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 1 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<1,10> (1848 solutions, 45 checks)))
            Access Hist:
            | width | R | W |
            | 10 | 1 | 10 |
          - Duplicate costs 1811.642324201308 (SRAM LUTs: 23.50877192982456%, FFs: 1.4668856048166392%, BRAMs: 1786.6666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 2 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<10,1> (1848 solutions, 45 checks)))
            Access Hist:
            | width | R | W |
            | 10 | 1 | 10 |
          - Duplicate costs 1668.7839618202595 (SRAM LUTs: 21.65497076023392%, FFs: 1.351213282247765%, BRAMs: 1645.7777777777778%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 271.74634863019617 for version 0 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 273.09832051392846 for version 1 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 271.74634863019617 for version 0 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Cost: 273.09832051392846 for version 1 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Cost: 271.74634863019617 for version 0 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 1811.642324201308 for version 1 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 1668.7839618202595 for version 2 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 271.74634863019617 for version 0 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Cost: 1811.642324201308 for version 1 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Cost: 1668.7839618202595 for version 2 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  **************************************************************************************
    Reads:
      grp 0: x434 = SRAMRead(x321,List(b256, x433),Set(x432)) rd{0,0}
      grp 0:  b256  b195  b461     c   mod
      grp 0:     1     0     0     0     0
      grp 0:    -3     1    16     0     0rd
    Writes:
      grp 0: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{0,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    0    0
      grp 0:    0    1    0    0wr
      grp 0: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{1,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    1    0
      grp 0:    0    1    0    0wr
      grp 0: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{6,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    6    0
      grp 0:    0    1    0    0wr
      grp 0: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{3,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    3    0
      grp 0:    0    1    0    0wr
      grp 0: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{5,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    5    0
      grp 0:    0    1    0    0wr
      grp 0: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{4,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    4    0
      grp 0:    0    1    0    0wr
      grp 0: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{2,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    2    0
      grp 0:    0    1    0    0wr
      grp 0: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{9,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    9    0
      grp 0:    0    1    0    0wr
      grp 0: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{7,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    7    0
      grp 0:    0    1    0    0wr
      grp 0: x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) wr{8,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    8    0
      grp 0:    0    1    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List(0, 0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Hierarchical>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {0,0}
      - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 1] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {1,0}
      - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 2] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {2,0}
      - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 3] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {3,0}
      - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 4] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {4,0}
      - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 5] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {5,0}
      - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 6] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {6,0}
      - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 7] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {7,0}
      - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 8] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {8,0}
      - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 9] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {9,0}
      - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x434 = SRAMRead(x321,List(b256, x433),Set(x432)) {0,0}
      - ProjectTemplate.scala:54:16: out_host store out_sram
      - Scope: x437 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: out_sram (x321)
Type: SRAM2[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:23:29
Src:        val out_sram = SRAM[T](N,3)
Symbol:     x321 = SRAMNew(List(Const(100), Const(3)),SRAM2[Fix[TRUE,_10,_22]])
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0, 0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Hierarchical>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {0,0}
        - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 1] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {1,0}
        - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 2] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {2,0}
        - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 3] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {3,0}
        - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 4] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {4,0}
        - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 5] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {5,0}
        - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 6] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {6,0}
        - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 7] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {7,0}
        - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 8] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {8,0}
        - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 9] x394 = SRAMWrite(x321,x393,List(b20, b81),Set()) {9,0}
        - ProjectTemplate.scala:51:28: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x434 = SRAMRead(x321,List(b256, x433),Set(x432)) {0,0}
        - ProjectTemplate.scala:54:16: out_host store out_sram
        - Scope: x437 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x434 {0,0}
  Added dispatch 0 to x434 {0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x394 {0,0}
  Added dispatch 0 to x394 {0,0}
  Added port Port(Some(0),0,1,List(1),List(0)) to x394 {1,0}
  Added dispatch 0 to x394 {1,0}
  Added port Port(Some(0),0,6,List(6),List(0)) to x394 {6,0}
  Added dispatch 0 to x394 {6,0}
  Added port Port(Some(0),0,3,List(3),List(0)) to x394 {3,0}
  Added dispatch 0 to x394 {3,0}
  Added port Port(Some(0),0,5,List(5),List(0)) to x394 {5,0}
  Added dispatch 0 to x394 {5,0}
  Added port Port(Some(0),0,4,List(4),List(0)) to x394 {4,0}
  Added dispatch 0 to x394 {4,0}
  Added port Port(Some(0),0,2,List(2),List(0)) to x394 {2,0}
  Added dispatch 0 to x394 {2,0}
  Added port Port(Some(0),0,9,List(9),List(0)) to x394 {9,0}
  Added dispatch 0 to x394 {9,0}
  Added port Port(Some(0),0,7,List(7),List(0)) to x394 {7,0}
  Added dispatch 0 to x394 {7,0}
  Added port Port(Some(0),0,8,List(8),List(0)) to x394 {8,0}
  Added dispatch 0 to x394 {8,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x434 {0,0}
  Added dispatch 0 to x434 {0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x394 {0,0}
  Added dispatch 0 to x394 {0,0}
  Added port Port(Some(0),0,1,List(1),List(0)) to x394 {1,0}
  Added dispatch 0 to x394 {1,0}
  Added port Port(Some(0),0,6,List(6),List(0)) to x394 {6,0}
  Added dispatch 0 to x394 {6,0}
  Added port Port(Some(0),0,3,List(3),List(0)) to x394 {3,0}
  Added dispatch 0 to x394 {3,0}
  Added port Port(Some(0),0,5,List(5),List(0)) to x394 {5,0}
  Added dispatch 0 to x394 {5,0}
  Added port Port(Some(0),0,4,List(4),List(0)) to x394 {4,0}
  Added dispatch 0 to x394 {4,0}
  Added port Port(Some(0),0,2,List(2),List(0)) to x394 {2,0}
  Added dispatch 0 to x394 {2,0}
  Added port Port(Some(0),0,9,List(9),List(0)) to x394 {9,0}
  Added dispatch 0 to x394 {9,0}
  Added port Port(Some(0),0,7,List(7),List(0)) to x394 {7,0}
  Added dispatch 0 to x394 {7,0}
  Added port Port(Some(0),0,8,List(8),List(0)) to x394 {8,0}
  Added dispatch 0 to x394 {8,0}
---------------------------------------------------------------------
INFERRING...
Name: force (x348)
Type: SRAM1[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:40:32
Src:              val force = SRAM[T](1)
Symbol:     x348 = SRAMNew(List(Const(1)),SRAM1[Fix[TRUE,_10,_22]])
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()), RegroupDims(List(0)))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x380 {0} [x383 (stage: -1)]
  1 Read Groups:
  Group #0
    x380 = SRAMRead(x348,List(Const(0)),Set()) rd{0}
       c  mod
       0    0rd
  Grouping 1 Writes: 
    Access: x374 {} [x375 (stage: -1)]
  1 Write Groups:
  Group #0
    x374 = SRAMWrite(x348,x373,List(Const(0)),Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x380 {0}: 
      x374 {}
    x380 <-> x374: LCA: x388 (stage: -1), coarse-dist: 1
    x374 <-> x374: LCA: x375 (stage: -1), coarse-dist: <None>
  x380 <-> x374 # LCA: x388 (stage: -1), Dist: Some(1)
  x374 <-> x374 # LCA: x388 (stage: -1), Dist: Some(0)
  Dephasing Iters: x380 = SRAMRead(x348,List(Const(0)),Set()) rd{0}
   c  mod
   0    0rd -> x383
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: ListBuffer(b67)
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
  General read dephasing rules for x348: (b67,List(0)) -> (b67,0)
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x380 = SRAMRead(x348,List(Const(0)),Set()) rd{0}
   c  mod
   0    0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x375: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x374: SRAMWrite
    x383: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x380: SRAMRead
  **************************************************************************************
  Analyzing costs for banking schemes found for force (x348)
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.45065729457743975 (SRAM LUTs: 0.005847953216374269%, FFs: 3.6489691662105453E-4%, BRAMs: 0.4444444444444444%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 0.45065729457743975 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x380 = SRAMRead(x348,List(Const(0)),Set()) rd{0}
      grp 0:    c  mod
      grp 0:    0    0rd
    Writes:
      grp 0: x374 = SRAMWrite(x348,x373,List(Const(0)),Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    2
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: x388 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x374 = SRAMWrite(x348,x373,List(Const(0)),Set()) {}
      - ProjectTemplate.scala:44:22: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}
      - Scope: x375 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x380 = SRAMRead(x348,List(Const(0)),Set()) {0}
      - ProjectTemplate.scala:46:38: tmp(k) = tmp(k)*dt*force(0)
      - Scope: x383 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: force (x348)
Type: SRAM1[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:40:32
Src:              val force = SRAM[T](1)
Symbol:     x348 = SRAMNew(List(Const(1)),SRAM1[Fix[TRUE,_10,_22]])
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    2
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: x388 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x374 = SRAMWrite(x348,x373,List(Const(0)),Set()) {}
        - ProjectTemplate.scala:44:22: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}
        - Scope: x375 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x380 = SRAMRead(x348,List(Const(0)),Set()) {0}
        - ProjectTemplate.scala:46:38: tmp(k) = tmp(k)*dt*force(0)
        - Scope: x383 (scope: 0, 0)
  M [Type:WR]:
  M [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(1),0,0,List(0),List(0)) to x380 {0}
  Added dispatch 0 to x380 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x374 {}
  Added dispatch 0 to x374 {}
  Added port Port(Some(1),0,0,List(0),List(0)) to x380 {0}
  Added dispatch 0 to x380 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x374 {}
  Added dispatch 0 to x374 {}
---------------------------------------------------------------------
INFERRING...
Name: x397
Type: StreamOut[BurstCmd]
Src:  ProjectTemplate.scala:54:16
Src:        out_host store out_sram
Symbol:     x397 = StreamOutNew(BurstCmdBus)
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 0 Reads: 

  <No Read Groups>
  Grouping 1 Writes: 
    Access: x420 {0} [x424 (stage: -1)]
  1 Write Groups:
  Group #0
    x420 = StreamOutWrite(x397,x418,Set(x419)) wr{0}
     b256     c   mod
        1     0     0wr
  x420 <-> x420: LCA: x424 (stage: -1), coarse-dist: <None>
Dephasing Iters: x420 = StreamOutWrite(x397,x418,Set(x419)) wr{0}
 b256     c   mod
    1     0     0wr -> x424
Leaf: x424, Iters: ListBuffer(b256), target: x442, elements: ListBuffer(b256)
Current: x424
Current: x438
Leaf: x424, Iters: ListBuffer(b256), target: x442, elements: List(0)
Current: x424
Current: x438
Leaf: x424, Iters: ListBuffer(b256), target: x442, elements: List(0)
Current: x424
Current: x438
General write dephasing rules for x397: (b256,List(0)) -> (b256,0)
solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
x424: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
  x420: StreamOutWrite
**************************************************************************************
Analyzing costs for banking schemes found for x397
Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
  - 0 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
          Access Hist:
          | width | R | W |
          | 1 | 0 | 1 |
        - Duplicate costs 0.0 (LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
***** Cost summary *****
Cost: 0.0 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
**************************************************************************************
  Reads:
  Writes:
    grp 0: x420 = StreamOutWrite(x397,x418,Set(x419)) wr{0}
    grp 0:  b256     c   mod
    grp 0:     1     0     0wr
  Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x420 = StreamOutWrite(x397,x418,Set(x419)) {0}
      - ProjectTemplate.scala:54:16: out_host store out_sram
      - Scope: x424 (scope: 0, 0)
0 [Type:RD]:))
---------------------------------------------------------------------
SUMMARY: 
Name: x397
Type: StreamOut[BurstCmd]
Src:  ProjectTemplate.scala:54:16
Src:        out_host store out_sram
Symbol:     x397 = StreamOutNew(BurstCmdBus)
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x420 = StreamOutWrite(x397,x418,Set(x419)) {0}
        - ProjectTemplate.scala:54:16: out_host store out_sram
        - Scope: x424 (scope: 0, 0)
  0 [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x420 {0}
  Added dispatch 0 to x420 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x420 {0}
  Added dispatch 0 to x420 {0}
---------------------------------------------------------------------
INFERRING...
Name: x270
Type: FIFO[IssuedCmd]
Src:  ProjectTemplate.scala:21:14
Src:        A_sram load A_dram
Symbol:     x270 = FIFONew(Const(16))
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x299 {0} [x306 (stage: -1)]
  1 Read Groups:
  Group #0
    x299 = FIFODeq(x270,Set(Const(true))) rd{0}
     b251     c   mod
        1     0     0rd
  Grouping 1 Writes: 
    Access: x291 {0} [x292 (stage: -1)]
  1 Write Groups:
  Group #0
    x291 = FIFOEnq(x270,x290,Set(Const(true))) wr{0}
     b247     c   mod
        1     0     0wr



Merging memory instance groups:
Group #0: 
  Dephasing Iters: x299 = FIFODeq(x270,Set(Const(true))) rd{0}
 b251     c   mod
    1     0     0rd -> x306
  Leaf: x306, Iters: ListBuffer(b251), target: x319, elements: ListBuffer(b251)
  Current: x306
  Leaf: x306, Iters: ListBuffer(b251), target: x319, elements: List(0)
  Current: x306
  Leaf: x306, Iters: ListBuffer(b251), target: x319, elements: List(0)
  Current: x306
  General read dephasing rules for x270: (b251,List(0)) -> (b251,0)
  Dephasing Iters: x291 = FIFOEnq(x270,x290,Set(Const(true))) wr{0}
 b247     c   mod
    1     0     0wr -> x292
  Leaf: x292, Iters: ListBuffer(b247), target: x292, elements: ListBuffer(b247)
  Leaf: x292, Iters: ListBuffer(b247), target: x292, elements: List(0)
  Leaf: x292, Iters: ListBuffer(b247), target: x292, elements: List(0)
  General write dephasing rules for x270: (b247,List(0)) -> (b247,0)
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 3.605258356619518 (LUTs: 0.04678362573099415%, FFs: 0.0029191753329684362%, BRAMs: 3.5555555555555554%)
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x270
Type: FIFO[IssuedCmd]
Src:  ProjectTemplate.scala:21:14
Src:        A_sram load A_dram
Symbol:     x270 = FIFONew(Const(16))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x291 = FIFOEnq(x270,x290,Set(Const(true))) {0}
        - ProjectTemplate.scala:21:14: A_sram load A_dram
        - Scope: x292 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x299 = FIFODeq(x270,Set(Const(true))) {0}
        - ProjectTemplate.scala:21:14: A_sram load A_dram
        - Scope: x306 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x299 {0}
  Added dispatch 0 to x299 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x291 {0}
  Added dispatch 0 to x291 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x299 {0}
  Added dispatch 0 to x299 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x291 {0}
  Added dispatch 0 to x291 {0}
---------------------------------------------------------------------
INFERRING...
Name: x349
Type: Reg[Bit]
Src:  ProjectTemplate.scala:44:43
Src:  	    force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)
Symbol:     x349 = RegNew(Const(false))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 2 Reads: 
    Access: x360 {} [x373 (stage: -1)]
    Access: x361 {} [x371 (stage: -1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
  2 Read Groups:
  Group #0
    x360 = RegRead(x349) rd{}
       c  modrd
  Group #1
    x361 = RegRead(x349) rd{}
       c  modrd
  Grouping 1 Writes: 
    Access: x356 {} [x358 (stage: -1)]
  1 Write Groups:
  Group #0
    x356 = RegWrite(x349,x354,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x360 {}: 
      x356 {}
    x360 <-> x356: LCA: x388 (stage: -1), coarse-dist: 1
    x356 <-> x356: LCA: x358 (stage: -1), coarse-dist: <None>
  x360 <-> x356 # LCA: x388 (stage: -1), Dist: Some(1)
  x356 <-> x356 # LCA: x388 (stage: -1), Dist: Some(0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x360 = RegRead(x349) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x358: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x356: RegWrite
    x373: Switch (-1) [Level: InnerControl, Loop: Single, Schedule: Fork]
      x360: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x349
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.45065729457743975 (LUTs: 0.005847953216374269%, FFs: 3.6489691662105453E-4%, BRAMs: 0.4444444444444444%)
  ***** Cost summary *****
  Cost: 0.45065729457743975 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x360 = RegRead(x349) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x356 = RegWrite(x349,x354,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    2
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x388 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x356 = RegWrite(x349,x354,Set()) {}
      - ProjectTemplate.scala:44:43: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
      - Scope: x358 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x360 = RegRead(x349) {}
      - ProjectTemplate.scala:44:43: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
      - Scope: x373 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Result: Created instance #0
Group #1: 
    Preceding writes for x361 {}: 
      x356 {}
    x361 <-> x356: LCA: x388 (stage: -1), coarse-dist: 1
    x356 <-> x356: LCA: x358 (stage: -1), coarse-dist: <None>
  x361 <-> x356 # LCA: x388 (stage: -1), Dist: Some(1)
  x356 <-> x356 # LCA: x388 (stage: -1), Dist: Some(0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x361 = RegRead(x349) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x358: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x356: RegWrite
    x373: Switch (-1) [Level: InnerControl, Loop: Single, Schedule: Fork]
      x361: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x349
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.45065729457743975 (LUTs: 0.005847953216374269%, FFs: 3.6489691662105453E-4%, BRAMs: 0.4444444444444444%)
  ***** Cost summary *****
  Cost: 0.45065729457743975 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x361 = RegRead(x349) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x356 = RegWrite(x349,x354,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    2
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x388 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x356 = RegWrite(x349,x354,Set()) {}
      - ProjectTemplate.scala:44:43: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
      - Scope: x358 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x361 = RegRead(x349) {}
      - ProjectTemplate.scala:44:43: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
      - Scope: x371 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #1 with instance #0: 
    Computing overlaps: x361 = Some(RegRead(x349)) - x360 = Some(RegRead(x349))
    Computing overlaps: x356 = Some(RegWrite(x349,x354,Set())) - x356 = Some(RegWrite(x349,x354,Set()))
      x361 <-> x356: LCA: x388 (stage: -1), coarse-dist: 1
      x360 <-> x356: LCA: x388 (stage: -1), coarse-dist: 1
      x356 <-> x356: LCA: x358 (stage: -1), coarse-dist: <None>
      Preceding writes for x361 {}: 
        x356 {}
      Preceding writes for x360 {}: 
      x361 <-> x356: LCA: x388 (stage: -1), coarse-dist: 1
      x360 <-> x356: LCA: x388 (stage: -1), coarse-dist: 1
      x356 <-> x356: LCA: x358 (stage: -1), coarse-dist: <None>
    x361 <-> x356 # LCA: x388 (stage: -1), Dist: Some(1)
    x360 <-> x356 # LCA: x388 (stage: -1), Dist: Some(1)
    x356 <-> x356 # LCA: x388 (stage: -1), Dist: Some(0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x361 = RegRead(x349) rd{}
   c  modrd, x360 = RegRead(x349) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x358: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
        x356: RegWrite
      x373: Switch (-1) [Level: InnerControl, Loop: Single, Schedule: Fork]
        x361: RegRead
        x360: RegRead
    **************************************************************************************
    Analyzing costs for banking schemes found for x349
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 2 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 2 | 1 |
            - Duplicate costs 0.9013145891548795 (LUTs: 0.011695906432748537%, FFs: 7.297938332421091E-4%, BRAMs: 0.8888888888888888%)
    ***** Cost summary *****
    Cost: 0.9013145891548795 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x361 = RegRead(x349) rd{}
        grp 0:    c  modrd
        grp 2: x360 = RegRead(x349) rd{}
        grp 2:    c  modrd
      Writes:
        grp 0: x356 = RegWrite(x349,x354,Set()) wr{}
        grp 0:    c  mod
        grp 0:    0    0wr
      Result: Right(List(<Banked>
Depth:    2
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x388 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x356 = RegWrite(x349,x354,Set()) {}
      - ProjectTemplate.scala:44:43: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
      - Scope: x358 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x361 = RegRead(x349) {}
      - ProjectTemplate.scala:44:43: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
      - Scope: x371 (scope: 0, 0)
  [Ofs: 1] x360 = RegRead(x349) {}
      - ProjectTemplate.scala:44:43: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
      - Scope: x373 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Result: Merged 1 into instance 0
---------------------------------------------------------------------
SUMMARY: 
Name: x349
Type: Reg[Bit]
Src:  ProjectTemplate.scala:44:43
Src:  	    force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)
Symbol:     x349 = RegNew(Const(false))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    2
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: x388 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x356 = RegWrite(x349,x354,Set()) {}
        - ProjectTemplate.scala:44:43: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
        - Scope: x358 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x361 = RegRead(x349) {}
        - ProjectTemplate.scala:44:43: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
        - Scope: x371 (scope: 0, 0)
    [Ofs: 1] x360 = RegRead(x349) {}
        - ProjectTemplate.scala:44:43: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
        - Scope: x373 (scope: -1, -1)
  M [Type:WR]:
  M [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(1),0,0,List(0),List(0)) to x361 {}
  Added dispatch 0 to x361 {}
  Added port Port(Some(1),0,1,List(1),List(0)) to x360 {}
  Added dispatch 0 to x360 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x356 {}
  Added dispatch 0 to x356 {}
  Added port Port(Some(1),0,0,List(0),List(0)) to x361 {}
  Added dispatch 0 to x361 {}
  Added port Port(Some(1),0,1,List(1),List(0)) to x360 {}
  Added dispatch 0 to x360 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x356 {}
  Added dispatch 0 to x356 {}
---------------------------------------------------------------------
INFERRING...
Name: x297
Type: Reg[Fix[TRUE,_32,_0]]
Src:  ProjectTemplate.scala:21:14
Src:        A_sram load A_dram
Symbol:     x297 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x312 {0} [x318 (stage: -1)]
  1 Read Groups:
  Group #0
    x312 = RegRead(x297) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x303 {} [x306 (stage: -1)]
  1 Write Groups:
  Group #0
    x303 = RegWrite(x297,x302,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x312 {0}: 
      x303 {}
    x312 <-> x303: LCA: x319 (stage: -1), coarse-dist: <None>
    x303 <-> x303: LCA: x306 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x312 = RegRead(x297) rd{0}
   c  modrd -> x318
  Leaf: x318, Iters: ListBuffer(b146), target: x318, elements: ListBuffer(b146)
  Leaf: x318, Iters: ListBuffer(b146), target: x318, elements: List(0)
  Leaf: x318, Iters: ListBuffer(b146), target: x318, elements: List(0)
  General read dephasing rules for x297: (b146,List(0)) -> (b146,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x312 = RegRead(x297) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x319: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    x306: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x303: RegWrite
    x318: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x312: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x297
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x312 = RegRead(x297) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x303 = RegWrite(x297,x302,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x303 = RegWrite(x297,x302,Set()) {}
      - ProjectTemplate.scala:21:14: A_sram load A_dram
      - Scope: x306 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x312 = RegRead(x297) {0}
      - ProjectTemplate.scala:21:14: A_sram load A_dram
      - Scope: x318 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x297
Type: Reg[Fix[TRUE,_32,_0]]
Src:  ProjectTemplate.scala:21:14
Src:        A_sram load A_dram
Symbol:     x297 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x303 = RegWrite(x297,x302,Set()) {}
        - ProjectTemplate.scala:21:14: A_sram load A_dram
        - Scope: x306 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x312 = RegRead(x297) {0}
        - ProjectTemplate.scala:21:14: A_sram load A_dram
        - Scope: x318 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x312 {0}
  Added dispatch 0 to x312 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x303 {}
  Added dispatch 0 to x303 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x312 {0}
  Added dispatch 0 to x312 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x303 {}
  Added dispatch 0 to x303 {}
---------------------------------------------------------------------
INFERRING...
Name: tmp (x329)
Type: SRAM1[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:34:30
Src:  	    val tmp = SRAM[T](3).buffer
Symbol:     x329 = SRAMNew(List(Const(3)),SRAM1[Fix[TRUE,_10,_22]])
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()), RegroupDims(List(0)))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 5 Reads: 
    Access: x338 {} [x347 (stage: -1)]
    Access: x340 {} [x347 (stage: -1)]
Computing overlaps: x340 = Some(SRAMRead(x329,List(Const(1)),Set())) - x338 = Some(SRAMRead(x329,List(Const(0)),Set()))
      Group #0 conflicts: <none>
      Group #0 same port: <1 accesses>
    Access: x343 {} [x347 (stage: -1)]
Computing overlaps: x343 = Some(SRAMRead(x329,List(Const(2)),Set())) - x338 = Some(SRAMRead(x329,List(Const(0)),Set()))
Computing overlaps: x343 = Some(SRAMRead(x329,List(Const(2)),Set())) - x340 = Some(SRAMRead(x329,List(Const(1)),Set()))
      Group #0 conflicts: <none>
      Group #0 same port: <2 accesses>
    Access: x378 {0} [x383 (stage: -1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
    Access: x384 {0} [x388 (stage: 1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
      Group #1 conflicts: <none>
      Group #1 same port: <none> 
  3 Read Groups:
  Group #0
    x338 = SRAMRead(x329,List(Const(0)),Set()) rd{}
       c  mod
       0    0rd
    x340 = SRAMRead(x329,List(Const(1)),Set()) rd{}
       c  mod
       1    0rd
    x343 = SRAMRead(x329,List(Const(2)),Set()) rd{}
       c  mod
       2    0rd
  Group #1
    x378 = SRAMRead(x329,List(b67),Set()) rd{0}
     b67    c  mod
       1    0    0rd
  Group #2
    x384 = SRAMRead(x329,List(b28),Set()) rd{0}
     b28    c  mod
       1    0    0rd
  Grouping 2 Writes: 
    Access: x335 {0} [x336 (stage: -1)]
    Access: x382 {0} [x383 (stage: -1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
  2 Write Groups:
  Group #0
    x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
     b33    c  mod
       1    0    0wr
  Group #1
    x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
     b67    c  mod
       1    0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x338 {}: 
      x335 {0}
      x382 {0}
  Mustfollow: x335 -> x382 -> x338 [true]
    CtrlA: x388 (stage: -1) [-4]
    CtrlB: x388 (stage: -1) [1]
    IsStream: false
    ctrlAB: x388 (stage: -1)
  Mustfollow: x382 -> x335 -> x338 [true]
    CtrlA: x388 (stage: -1) [1]
    CtrlB: x388 (stage: -1) [-4]
    IsStream: false
    ctrlAB: x388 (stage: -1)
    Preceding writes for x340 {}: 
    Preceding writes for x343 {}: 
    x340 <-> x335: LCA: x388 (stage: -1), coarse-dist: 1
    x343 <-> x335: LCA: x388 (stage: -1), coarse-dist: 1
    x382 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
    x335 <-> x335: LCA: x336 (stage: -1), coarse-dist: <None>
    x338 <-> x335: LCA: x388 (stage: -1), coarse-dist: 1
    x340 <-> x382: LCA: x388 (stage: -1), coarse-dist: -4
    x343 <-> x382: LCA: x388 (stage: -1), coarse-dist: -4
    x382 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
    x335 <-> x382: LCA: x388 (stage: -1), coarse-dist: -5
    x338 <-> x382: LCA: x388 (stage: -1), coarse-dist: -4
  x340 <-> x335 # LCA: x388 (stage: -1), Dist: Some(1)
  x343 <-> x335 # LCA: x388 (stage: -1), Dist: Some(1)
  x382 <-> x335 # LCA: x388 (stage: -1), Dist: Some(5)
  x335 <-> x335 # LCA: x388 (stage: -1), Dist: Some(0)
  x338 <-> x335 # LCA: x388 (stage: -1), Dist: Some(1)
  Dephasing Iters: x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
 b33    c  mod
   1    0    0wr -> x336
  Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: ListBuffer(b33)
  Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
  Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
  Dephasing Iters: x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
 b67    c  mod
   1    0    0wr -> x383
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: ListBuffer(b67)
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
  General write dephasing rules for x329: (b33,List(0)) -> (b33,0)
  - (b67,List(0)) -> (b67,0)
  Finding scheme for BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Original banking group #0 has (1 accesses)
       b33    c  mod
         1    0    0wr
  Original banking group #1 has (1 accesses)
       b67    c  mod
         1    0    0wr
  Original banking group #2 has (3 accesses)
         c  mod
         0    0rd
         c  mod
         1    0rd
         c  mod
         2    0rd
  Regrouped banking group #0 has (1 accesses)
       b33    c  mod
         1    0    0wr
  Regrouped banking group #1 has (1 accesses)
       b67    c  mod
         1    0    0wr
  Regrouped banking group #2 has (3 accesses)
         c  mod
         0    0rd
         c  mod
         1    0rd
         c  mod
         2    0rd
   Solution space: 4 * 1 * 11 (B), check complexity: 4
       Checking N=3 and alpha=List(0)
       Checking N=3 and alpha=List(1)
       Success on N=3, alpha=List(1), B=1
       Checking N=3 and alpha=List(2)
       Success on N=3, alpha=List(2), B=1
         x329: Found 2 solutions after 12 (= 3 * 4) attempts to find solution for NBestGuess AlphaBestGuess List(0)
  Banking scheme List(Dims {0}: Cyclic: N=3, B=1, alpha=<1>, P=<3> (4 solutions, 4 checks)) accepted!
  incrementing Flat(1), RegroupDims(List()) to 1 
  Banking scheme List(Dims {0}: Cyclic: N=3, B=1, alpha=<2>, P=<3> (4 solutions, 4 checks)) accepted!
  incrementing Flat(1), RegroupDims(List()) to 2 
  Finding scheme for BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List(0)))
  Original banking group #0 has (1 accesses)
       b33    c  mod
         1    0    0wr
  Original banking group #1 has (1 accesses)
       b67    c  mod
         1    0    0wr
  Regrouped banking group #0 has (1 accesses)
       b33    c  mod
         1    0    0wr
  Regrouped banking group #1 has (1 accesses)
       b67    c  mod
         1    0    0wr
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(1), RegroupDims(List(0)) to 1 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(1), RegroupDims(List(0)) to 2 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(1), RegroupDims(List(0)) to 3 
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(1),NBestGuess,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(1),NBestGuess,AlphaRelaxed,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(1),NRelaxed,AlphaBestGuess,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(1),NRelaxed,AlphaBestGuess,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(1),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(1),NRelaxed,AlphaRelaxed,RegroupDims(List(0)))
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x338 = SRAMRead(x329,List(Const(0)),Set()) rd{}
   c  mod
   0    0rd, x340 = SRAMRead(x329,List(Const(1)),Set()) rd{}
   c  mod
   1    0rd, x343 = SRAMRead(x329,List(Const(2)),Set()) rd{}
   c  mod
   2    0rd)) -> List(List(Dims {0}: Cyclic: N=3, B=1, alpha=<1>, P=<3> (4 solutions, 4 checks)), List(Dims {0}: Cyclic: N=3, B=1, alpha=<2>, P=<3> (4 solutions, 4 checks)))), BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List(0))) -> Map(Set(Set(x338 = SRAMRead(x329,List(Const(0)),Set()) rd{}
   c  mod
   0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x340 = SRAMRead(x329,List(Const(1)),Set()) rd{}
   c  mod
   1    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x343 = SRAMRead(x329,List(Const(2)),Set()) rd{}
   c  mod
   2    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x336: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x335: SRAMWrite
    x347: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x340: SRAMRead
      x343: SRAMRead
      x338: SRAMRead
    x383: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x382: SRAMWrite
  **************************************************************************************
  Analyzing costs for banking schemes found for tmp (x329)
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 3 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=3, B=1, alpha=<1>, P=<3> (4 solutions, 4 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 3 | 0 |
            | 3 | 0 | 2 |
          - Duplicate costs 181.61488971470823 (SRAM LUTs: 2.3567251461988303%, FFs: 0.147053457398285%, BRAMs: 179.11111111111111%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 1 instance 0:
    - 3 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=3, B=1, alpha=<2>, P=<3> (4 solutions, 4 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 3 | 0 |
            | 3 | 0 | 2 |
          - Duplicate costs 181.61488971470823 (SRAM LUTs: 2.3567251461988303%, FFs: 0.147053457398285%, BRAMs: 179.11111111111111%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List(0))) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 2 |
          - Duplicate costs 4.055915651196958 (SRAM LUTs: 0.05263157894736842%, FFs: 0.003284072249589491%, BRAMs: 4.0%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List(0))) option 0 instance 1:
    - 1 readers connect to duplicate #1 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 2 |
          - Duplicate costs 4.055915651196958 (SRAM LUTs: 0.05263157894736842%, FFs: 0.003284072249589491%, BRAMs: 4.0%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List(0))) option 0 instance 2:
    - 1 readers connect to duplicate #2 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 2 |
          - Duplicate costs 4.055915651196958 (SRAM LUTs: 0.05263157894736842%, FFs: 0.003284072249589491%, BRAMs: 4.0%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 181.61488971470823 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 181.61488971470823 for version 1 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 12.167746953590875 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List(0)))
  **************************************************************************************
    Reads:
      grp 0: x338 = SRAMRead(x329,List(Const(0)),Set()) rd{}
      grp 0:    c  mod
      grp 0:    0    0rd
      grp 0: x340 = SRAMRead(x329,List(Const(1)),Set()) rd{}
      grp 0:    c  mod
      grp 0:    1    0rd
      grp 0: x343 = SRAMRead(x329,List(Const(2)),Set()) rd{}
      grp 0:    c  mod
      grp 0:    2    0rd
    Writes:
      grp 0: x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
      grp 0:  b33    c  mod
      grp 0:    1    0    0wr
      grp 1: x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
      grp 1:  b67    c  mod
      grp 1:    1    0    0wr
    Result: Right(List(<Banked>
Depth:    6
Padding:  List(0)
Accum:    Fold
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: x388 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x335 = SRAMWrite(x329,x334,List(b33),Set()) {0}
      - ProjectTemplate.scala:35:43: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x338 = SRAMRead(x329,List(Const(0)),Set()) {}
      - ProjectTemplate.scala:37:24: r(0) = (tmp(0)*tmp(0)) + (tmp(1)*tmp(1)) + (tmp(2)*tmp(2))
      - Scope: x347 (scope: 0, 0)
2 [Type:WR]:
2 [Type:RD]:
3 [Type:WR]:
3 [Type:RD]:
4 [Type:WR]:
4 [Type:RD]:
5 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x382 = SRAMWrite(x329,x381,List(b67),Set()) {0}
      - ProjectTemplate.scala:46:21: tmp(k) = tmp(k)*dt*force(0)
      - Scope: x383 (scope: 0, 0)
5 [Type:RD]:
M [Type:WR]:
M [Type:RD]:, <Banked>
Depth:    6
Padding:  List(0)
Accum:    Fold
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: x388 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x335 = SRAMWrite(x329,x334,List(b33),Set()) {0}
      - ProjectTemplate.scala:35:43: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x340 = SRAMRead(x329,List(Const(1)),Set()) {}
      - ProjectTemplate.scala:37:42: r(0) = (tmp(0)*tmp(0)) + (tmp(1)*tmp(1)) + (tmp(2)*tmp(2))
      - Scope: x347 (scope: 0, 0)
2 [Type:WR]:
2 [Type:RD]:
3 [Type:WR]:
3 [Type:RD]:
4 [Type:WR]:
4 [Type:RD]:
5 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x382 = SRAMWrite(x329,x381,List(b67),Set()) {0}
      - ProjectTemplate.scala:46:21: tmp(k) = tmp(k)*dt*force(0)
      - Scope: x383 (scope: 0, 0)
5 [Type:RD]:
M [Type:WR]:
M [Type:RD]:, <Banked>
Depth:    6
Padding:  List(0)
Accum:    Fold
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: x388 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x335 = SRAMWrite(x329,x334,List(b33),Set()) {0}
      - ProjectTemplate.scala:35:43: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x343 = SRAMRead(x329,List(Const(2)),Set()) {}
      - ProjectTemplate.scala:37:60: r(0) = (tmp(0)*tmp(0)) + (tmp(1)*tmp(1)) + (tmp(2)*tmp(2))
      - Scope: x347 (scope: 0, 0)
2 [Type:WR]:
2 [Type:RD]:
3 [Type:WR]:
3 [Type:RD]:
4 [Type:WR]:
4 [Type:RD]:
5 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x382 = SRAMWrite(x329,x381,List(b67),Set()) {0}
      - ProjectTemplate.scala:46:21: tmp(k) = tmp(k)*dt*force(0)
      - Scope: x383 (scope: 0, 0)
5 [Type:RD]:
M [Type:WR]:
M [Type:RD]:))
  Result: Created instance #2
Group #1: 
    Preceding writes for x378 {0}: 
      x335 {0}
      x382 {0}
  Mustfollow: x335 -> x382 -> x378 [true]
    CtrlA: x383 (stage: -1) [0]
    CtrlB: x388 (stage: -1) [5]
    IsStream: false
  Mustfollow: x382 -> x335 -> x378 [true]
    CtrlA: x388 (stage: -1) [5]
    CtrlB: x383 (stage: -1) [0]
    IsStream: false
    x378 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
    x335 <-> x335: LCA: x336 (stage: -1), coarse-dist: <None>
    x382 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
    x378 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
    x335 <-> x382: LCA: x388 (stage: -1), coarse-dist: -5
    x382 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
  x378 <-> x335 # LCA: x388 (stage: -1), Dist: Some(5)
  x335 <-> x335 # LCA: x388 (stage: -1), Dist: Some(0)
  x382 <-> x335 # LCA: x388 (stage: -1), Dist: Some(5)
  Dephasing Iters: x378 = SRAMRead(x329,List(b67),Set()) rd{0}
 b67    c  mod
   1    0    0rd -> x383
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: ListBuffer(b67)
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
  General read dephasing rules for x329: (b67,List(0)) -> (b67,0)
  Dephasing Iters: x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
 b33    c  mod
   1    0    0wr -> x336
  Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: ListBuffer(b33)
  Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
  Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
  Dephasing Iters: x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
 b67    c  mod
   1    0    0wr -> x383
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: ListBuffer(b67)
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
  General write dephasing rules for x329: (b33,List(0)) -> (b33,0)
  - (b67,List(0)) -> (b67,0)
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x378 = SRAMRead(x329,List(b67),Set()) rd{0}
 b67    c  mod
   1    0    0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x336: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x335: SRAMWrite
    x383: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x378: SRAMRead
      x382: SRAMWrite
  **************************************************************************************
  Analyzing costs for banking schemes found for tmp (x329)
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 2 |
          - Duplicate costs 4.055915651196958 (SRAM LUTs: 0.05263157894736842%, FFs: 0.003284072249589491%, BRAMs: 4.0%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 4.055915651196958 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x378 = SRAMRead(x329,List(b67),Set()) rd{0}
      grp 0:  b67    c  mod
      grp 0:    1    0    0rd
    Writes:
      grp 0: x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
      grp 0:  b33    c  mod
      grp 0:    1    0    0wr
      grp 1: x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
      grp 1:  b67    c  mod
      grp 1:    1    0    0wr
    Result: Right(List(<Banked>
Depth:    6
Padding:  List(0)
Accum:    Fold
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: x388 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x335 = SRAMWrite(x329,x334,List(b33),Set()) {0}
      - ProjectTemplate.scala:35:43: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
2 [Type:WR]:
2 [Type:RD]:
3 [Type:WR]:
3 [Type:RD]:
4 [Type:WR]:
4 [Type:RD]:
5 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x382 = SRAMWrite(x329,x381,List(b67),Set()) {0}
      - ProjectTemplate.scala:46:21: tmp(k) = tmp(k)*dt*force(0)
      - Scope: x383 (scope: 0, 0)
5 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x378 = SRAMRead(x329,List(b67),Set()) {0}
      - ProjectTemplate.scala:46:26: tmp(k) = tmp(k)*dt*force(0)
      - Scope: x383 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #1 with instance #0: 
    Computing overlaps: x378 = Some(SRAMRead(x329,List(b67),Set())) - x338 = Some(SRAMRead(x329,List(Const(0)),Set()))
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Dephasing Iters: x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
 b33    c  mod
   1    0    0wr -> x336
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: ListBuffer(b33)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Dephasing Iters: x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
 b67    c  mod
   1    0    0wr -> x383
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: ListBuffer(b67)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
      x378 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
      x338 <-> x335: LCA: x388 (stage: -1), coarse-dist: 1
      x335 <-> x335: LCA: x336 (stage: -1), coarse-dist: <None>
      x382 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
      x378 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
      x338 <-> x382: LCA: x388 (stage: -1), coarse-dist: -4
      x335 <-> x382: LCA: x388 (stage: -1), coarse-dist: -5
      x382 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
    Did not merge 1 into instance 0: Accumulator conflict (A Type: Fold, B Type: Fold)
  Attempting to merge group #1 with instance #1: 
    Computing overlaps: x378 = Some(SRAMRead(x329,List(b67),Set())) - x340 = Some(SRAMRead(x329,List(Const(1)),Set()))
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Dephasing Iters: x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
 b33    c  mod
   1    0    0wr -> x336
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: ListBuffer(b33)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Dephasing Iters: x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
 b67    c  mod
   1    0    0wr -> x383
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: ListBuffer(b67)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
      x378 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
      x340 <-> x335: LCA: x388 (stage: -1), coarse-dist: 1
      x335 <-> x335: LCA: x336 (stage: -1), coarse-dist: <None>
      x382 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
      x378 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
      x340 <-> x382: LCA: x388 (stage: -1), coarse-dist: -4
      x335 <-> x382: LCA: x388 (stage: -1), coarse-dist: -5
      x382 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
    Did not merge 1 into instance 1: Accumulator conflict (A Type: Fold, B Type: Fold)
  Attempting to merge group #1 with instance #2: 
    Computing overlaps: x378 = Some(SRAMRead(x329,List(b67),Set())) - x343 = Some(SRAMRead(x329,List(Const(2)),Set()))
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Dephasing Iters: x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
 b33    c  mod
   1    0    0wr -> x336
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: ListBuffer(b33)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Dephasing Iters: x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
 b67    c  mod
   1    0    0wr -> x383
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: ListBuffer(b67)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
      x378 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
      x343 <-> x335: LCA: x388 (stage: -1), coarse-dist: 1
      x335 <-> x335: LCA: x336 (stage: -1), coarse-dist: <None>
      x382 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
      x378 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
      x343 <-> x382: LCA: x388 (stage: -1), coarse-dist: -4
      x335 <-> x382: LCA: x388 (stage: -1), coarse-dist: -5
      x382 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
    Did not merge 1 into instance 2: Accumulator conflict (A Type: Fold, B Type: Fold)
  Result: Created instance #3
Group #2: 
    Preceding writes for x384 {0}: 
      x335 {0}
      x382 {0}
  Mustfollow: x335 -> x382 -> x384 [true]
    CtrlA: x388 (stage: -1) [1]
    CtrlB: x388 (stage: -1) [6]
    IsStream: false
    ctrlAB: x388 (stage: -1)
  Mustfollow: x382 -> x335 -> x384 [true]
    CtrlA: x388 (stage: -1) [6]
    CtrlB: x388 (stage: -1) [1]
    IsStream: false
    ctrlAB: x388 (stage: -1)
    x384 <-> x335: LCA: x388 (stage: -1), coarse-dist: 6
    x335 <-> x335: LCA: x336 (stage: -1), coarse-dist: <None>
    x382 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
    x384 <-> x382: LCA: x388 (stage: -1), coarse-dist: 1
    x335 <-> x382: LCA: x388 (stage: -1), coarse-dist: -5
    x382 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
  x384 <-> x335 # LCA: x388 (stage: -1), Dist: Some(6)
  x335 <-> x335 # LCA: x388 (stage: -1), Dist: Some(0)
  x382 <-> x335 # LCA: x388 (stage: -1), Dist: Some(5)
  Dephasing Iters: x384 = SRAMRead(x329,List(b28),Set()) rd{0}
 b28    c  mod
   1    0    0rd -> x388
  Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: ListBuffer(b28)
  Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: List(0)
  Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: List(0)
  General read dephasing rules for x329: (b28,List(0)) -> (b28,0)
  Dephasing Iters: x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
 b33    c  mod
   1    0    0wr -> x336
  Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: ListBuffer(b33)
  Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
  Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
  Dephasing Iters: x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
 b67    c  mod
   1    0    0wr -> x383
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: ListBuffer(b67)
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
  Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
  General write dephasing rules for x329: (b33,List(0)) -> (b33,0)
  - (b67,List(0)) -> (b67,0)
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x384 = SRAMRead(x329,List(b28),Set()) rd{0}
 b28    c  mod
   1    0    0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x336: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x335: SRAMWrite
    x383: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x382: SRAMWrite
    x388: OpMemReduce (1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x384: SRAMRead
  **************************************************************************************
  Analyzing costs for banking schemes found for tmp (x329)
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 2 |
          - Duplicate costs 4.731901593063117 (SRAM LUTs: 0.06140350877192982%, FFs: 0.0038314176245210726%, BRAMs: 4.666666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 4.731901593063117 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x384 = SRAMRead(x329,List(b28),Set()) rd{0}
      grp 0:  b28    c  mod
      grp 0:    1    0    0rd
    Writes:
      grp 0: x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
      grp 0:  b33    c  mod
      grp 0:    1    0    0wr
      grp 1: x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
      grp 1:  b67    c  mod
      grp 1:    1    0    0wr
    Result: Right(List(<Banked>
Depth:    7
Padding:  List(0)
Accum:    Fold
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: x388 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x335 = SRAMWrite(x329,x334,List(b33),Set()) {0}
      - ProjectTemplate.scala:35:43: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
2 [Type:WR]:
2 [Type:RD]:
3 [Type:WR]:
3 [Type:RD]:
4 [Type:WR]:
4 [Type:RD]:
5 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x382 = SRAMWrite(x329,x381,List(b67),Set()) {0}
      - ProjectTemplate.scala:46:21: tmp(k) = tmp(k)*dt*force(0)
      - Scope: x383 (scope: 0, 0)
5 [Type:RD]:
6 [Type:WR]:
6 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x384 = SRAMRead(x329,List(b28),Set()) {0}
      - ProjectTemplate.scala:49:10: }{_+_}
      - Scope: x388 (scope: 1, 0)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #2 with instance #0: 
    Computing overlaps: x384 = Some(SRAMRead(x329,List(b28),Set())) - x338 = Some(SRAMRead(x329,List(Const(0)),Set()))
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Dephasing Iters: x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
 b33    c  mod
   1    0    0wr -> x336
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: ListBuffer(b33)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Dephasing Iters: x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
 b67    c  mod
   1    0    0wr -> x383
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: ListBuffer(b67)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
      x384 <-> x335: LCA: x388 (stage: -1), coarse-dist: 6
      x338 <-> x335: LCA: x388 (stage: -1), coarse-dist: 1
      x335 <-> x335: LCA: x336 (stage: -1), coarse-dist: <None>
      x382 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
      x384 <-> x382: LCA: x388 (stage: -1), coarse-dist: 1
      x338 <-> x382: LCA: x388 (stage: -1), coarse-dist: -4
      x335 <-> x382: LCA: x388 (stage: -1), coarse-dist: -5
      x382 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
    Did not merge 2 into instance 0: Accumulator conflict (A Type: Fold, B Type: Fold)
  Attempting to merge group #2 with instance #1: 
    Computing overlaps: x384 = Some(SRAMRead(x329,List(b28),Set())) - x340 = Some(SRAMRead(x329,List(Const(1)),Set()))
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Dephasing Iters: x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
 b33    c  mod
   1    0    0wr -> x336
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: ListBuffer(b33)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Dephasing Iters: x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
 b67    c  mod
   1    0    0wr -> x383
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: ListBuffer(b67)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
      x384 <-> x335: LCA: x388 (stage: -1), coarse-dist: 6
      x340 <-> x335: LCA: x388 (stage: -1), coarse-dist: 1
      x335 <-> x335: LCA: x336 (stage: -1), coarse-dist: <None>
      x382 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
      x384 <-> x382: LCA: x388 (stage: -1), coarse-dist: 1
      x340 <-> x382: LCA: x388 (stage: -1), coarse-dist: -4
      x335 <-> x382: LCA: x388 (stage: -1), coarse-dist: -5
      x382 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
    Did not merge 2 into instance 1: Accumulator conflict (A Type: Fold, B Type: Fold)
  Attempting to merge group #2 with instance #2: 
    Computing overlaps: x384 = Some(SRAMRead(x329,List(b28),Set())) - x343 = Some(SRAMRead(x329,List(Const(2)),Set()))
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Dephasing Iters: x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
 b33    c  mod
   1    0    0wr -> x336
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: ListBuffer(b33)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Dephasing Iters: x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
 b67    c  mod
   1    0    0wr -> x383
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: ListBuffer(b67)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
      x384 <-> x335: LCA: x388 (stage: -1), coarse-dist: 6
      x343 <-> x335: LCA: x388 (stage: -1), coarse-dist: 1
      x335 <-> x335: LCA: x336 (stage: -1), coarse-dist: <None>
      x382 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
      x384 <-> x382: LCA: x388 (stage: -1), coarse-dist: 1
      x343 <-> x382: LCA: x388 (stage: -1), coarse-dist: -4
      x335 <-> x382: LCA: x388 (stage: -1), coarse-dist: -5
      x382 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
    Did not merge 2 into instance 2: Accumulator conflict (A Type: Fold, B Type: Fold)
  Attempting to merge group #2 with instance #3: 
    Computing overlaps: x384 = Some(SRAMRead(x329,List(b28),Set())) - x378 = Some(SRAMRead(x329,List(b67),Set()))
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Dephasing Iters: x335 = SRAMWrite(x329,x334,List(b33),Set()) wr{0}
 b33    c  mod
   1    0    0wr -> x336
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: ListBuffer(b33)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Leaf: x336, Iters: ListBuffer(b33), target: x336, elements: List(0)
    Computing overlaps: x335 = Some(SRAMWrite(x329,x334,List(b33),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x335 = Some(SRAMWrite(x329,x334,List(b33),Set()))
    Computing overlaps: x382 = Some(SRAMWrite(x329,x381,List(b67),Set())) - x382 = Some(SRAMWrite(x329,x381,List(b67),Set()))
    Dephasing Iters: x382 = SRAMWrite(x329,x381,List(b67),Set()) wr{0}
 b67    c  mod
   1    0    0wr -> x383
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: ListBuffer(b67)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
    Leaf: x383, Iters: ListBuffer(b67), target: x383, elements: List(0)
      x384 <-> x335: LCA: x388 (stage: -1), coarse-dist: 6
      x378 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
      x335 <-> x335: LCA: x336 (stage: -1), coarse-dist: <None>
      x382 <-> x335: LCA: x388 (stage: -1), coarse-dist: 5
      x384 <-> x382: LCA: x388 (stage: -1), coarse-dist: 1
      x378 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
      x335 <-> x382: LCA: x388 (stage: -1), coarse-dist: -5
      x382 <-> x382: LCA: x383 (stage: -1), coarse-dist: <None>
    Did not merge 2 into instance 3: Accumulator conflict (A Type: Fold, B Type: Fold)
  Result: Created instance #4
---------------------------------------------------------------------
SUMMARY: 
Name: tmp (x329)
Type: SRAM1[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:34:30
Src:  	    val tmp = SRAM[T](3).buffer
Symbol:     x329 = SRAMNew(List(Const(3)),SRAM1[Fix[TRUE,_10,_22]])
---------------------------------------------------------------------
Instances: 5
Instance #0
  <Banked>
  Depth:    6
  Padding:  List(0)
  Accum:    Fold
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: x388 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x335 = SRAMWrite(x329,x334,List(b33),Set()) {0}
        - ProjectTemplate.scala:35:43: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x338 = SRAMRead(x329,List(Const(0)),Set()) {}
        - ProjectTemplate.scala:37:24: r(0) = (tmp(0)*tmp(0)) + (tmp(1)*tmp(1)) + (tmp(2)*tmp(2))
        - Scope: x347 (scope: 0, 0)
  2 [Type:WR]:
  2 [Type:RD]:
  3 [Type:WR]:
  3 [Type:RD]:
  4 [Type:WR]:
  4 [Type:RD]:
  5 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x382 = SRAMWrite(x329,x381,List(b67),Set()) {0}
        - ProjectTemplate.scala:46:21: tmp(k) = tmp(k)*dt*force(0)
        - Scope: x383 (scope: 0, 0)
  5 [Type:RD]:
  M [Type:WR]:
  M [Type:RD]:



Instance #1
  <Banked>
  Depth:    6
  Padding:  List(0)
  Accum:    Fold
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: x388 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x335 = SRAMWrite(x329,x334,List(b33),Set()) {0}
        - ProjectTemplate.scala:35:43: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x340 = SRAMRead(x329,List(Const(1)),Set()) {}
        - ProjectTemplate.scala:37:42: r(0) = (tmp(0)*tmp(0)) + (tmp(1)*tmp(1)) + (tmp(2)*tmp(2))
        - Scope: x347 (scope: 0, 0)
  2 [Type:WR]:
  2 [Type:RD]:
  3 [Type:WR]:
  3 [Type:RD]:
  4 [Type:WR]:
  4 [Type:RD]:
  5 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x382 = SRAMWrite(x329,x381,List(b67),Set()) {0}
        - ProjectTemplate.scala:46:21: tmp(k) = tmp(k)*dt*force(0)
        - Scope: x383 (scope: 0, 0)
  5 [Type:RD]:
  M [Type:WR]:
  M [Type:RD]:



Instance #2
  <Banked>
  Depth:    6
  Padding:  List(0)
  Accum:    Fold
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: x388 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x335 = SRAMWrite(x329,x334,List(b33),Set()) {0}
        - ProjectTemplate.scala:35:43: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x343 = SRAMRead(x329,List(Const(2)),Set()) {}
        - ProjectTemplate.scala:37:60: r(0) = (tmp(0)*tmp(0)) + (tmp(1)*tmp(1)) + (tmp(2)*tmp(2))
        - Scope: x347 (scope: 0, 0)
  2 [Type:WR]:
  2 [Type:RD]:
  3 [Type:WR]:
  3 [Type:RD]:
  4 [Type:WR]:
  4 [Type:RD]:
  5 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x382 = SRAMWrite(x329,x381,List(b67),Set()) {0}
        - ProjectTemplate.scala:46:21: tmp(k) = tmp(k)*dt*force(0)
        - Scope: x383 (scope: 0, 0)
  5 [Type:RD]:
  M [Type:WR]:
  M [Type:RD]:



Instance #3
  <Banked>
  Depth:    6
  Padding:  List(0)
  Accum:    Fold
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: x388 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x335 = SRAMWrite(x329,x334,List(b33),Set()) {0}
        - ProjectTemplate.scala:35:43: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
  2 [Type:WR]:
  2 [Type:RD]:
  3 [Type:WR]:
  3 [Type:RD]:
  4 [Type:WR]:
  4 [Type:RD]:
  5 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x382 = SRAMWrite(x329,x381,List(b67),Set()) {0}
        - ProjectTemplate.scala:46:21: tmp(k) = tmp(k)*dt*force(0)
        - Scope: x383 (scope: 0, 0)
  5 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x378 = SRAMRead(x329,List(b67),Set()) {0}
        - ProjectTemplate.scala:46:26: tmp(k) = tmp(k)*dt*force(0)
        - Scope: x383 (scope: 0, 0)
  M [Type:WR]:
  M [Type:RD]:



Instance #4
  <Banked>
  Depth:    7
  Padding:  List(0)
  Accum:    Fold
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: x388 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x335 = SRAMWrite(x329,x334,List(b33),Set()) {0}
        - ProjectTemplate.scala:35:43: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
  2 [Type:WR]:
  2 [Type:RD]:
  3 [Type:WR]:
  3 [Type:RD]:
  4 [Type:WR]:
  4 [Type:RD]:
  5 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x382 = SRAMWrite(x329,x381,List(b67),Set()) {0}
        - ProjectTemplate.scala:46:21: tmp(k) = tmp(k)*dt*force(0)
        - Scope: x383 (scope: 0, 0)
  5 [Type:RD]:
  6 [Type:WR]:
  6 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x384 = SRAMRead(x329,List(b28),Set()) {0}
        - ProjectTemplate.scala:49:10: }{_+_}
        - Scope: x388 (scope: 1, 0)
  M [Type:WR]:
  M [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(1),0,0,List(0),List(0)) to x338 {}
  Added dispatch 0 to x338 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x335 {0}
  Added dispatch 0 to x335 {0}
  Added port Port(Some(5),0,0,List(0),List(0)) to x382 {0}
  Added dispatch 0 to x382 {0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x338 {}
  Added dispatch 0 to x338 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x335 {0}
  Added dispatch 0 to x335 {0}
  Added port Port(Some(5),0,0,List(0),List(0)) to x382 {0}
  Added dispatch 0 to x382 {0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x340 {}
  Added dispatch 1 to x340 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x335 {0}
  Added dispatch 1 to x335 {0}
  Added port Port(Some(5),0,0,List(0),List(0)) to x382 {0}
  Added dispatch 1 to x382 {0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x340 {}
  Added dispatch 1 to x340 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x335 {0}
  Added dispatch 1 to x335 {0}
  Added port Port(Some(5),0,0,List(0),List(0)) to x382 {0}
  Added dispatch 1 to x382 {0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x343 {}
  Added dispatch 2 to x343 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x335 {0}
  Added dispatch 2 to x335 {0}
  Added port Port(Some(5),0,0,List(0),List(0)) to x382 {0}
  Added dispatch 2 to x382 {0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x343 {}
  Added dispatch 2 to x343 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x335 {0}
  Added dispatch 2 to x335 {0}
  Added port Port(Some(5),0,0,List(0),List(0)) to x382 {0}
  Added dispatch 2 to x382 {0}
  Added port Port(Some(5),0,0,List(0),List(0)) to x378 {0}
  Added dispatch 3 to x378 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x335 {0}
  Added dispatch 3 to x335 {0}
  Added port Port(Some(5),0,0,List(0),List(0)) to x382 {0}
  Added dispatch 3 to x382 {0}
  Added port Port(Some(5),0,0,List(0),List(0)) to x378 {0}
  Added dispatch 3 to x378 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x335 {0}
  Added dispatch 3 to x335 {0}
  Added port Port(Some(5),0,0,List(0),List(0)) to x382 {0}
  Added dispatch 3 to x382 {0}
  Added port Port(Some(6),0,0,List(0),List(0)) to x384 {0}
  Added dispatch 4 to x384 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x335 {0}
  Added dispatch 4 to x335 {0}
  Added port Port(Some(5),0,0,List(0),List(0)) to x382 {0}
  Added dispatch 4 to x382 {0}
  Added port Port(Some(6),0,0,List(0),List(0)) to x384 {0}
  Added dispatch 4 to x384 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x335 {0}
  Added dispatch 4 to x335 {0}
  Added port Port(Some(5),0,0,List(0),List(0)) to x382 {0}
  Added dispatch 4 to x382 {0}
---------------------------------------------------------------------
INFERRING...
Name: accum (x324)
Type: SRAM1[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:30:30
Src:  	  val accum = SRAM[T](3)
Symbol:     x324 = SRAMNew(List(Const(3)),SRAM1[Fix[TRUE,_10,_22]])
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()), RegroupDims(List(0)))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 2 Reads: 
    Access: x385 {0} [x388 (stage: 1)]
    Access: x391 {0} [x395 (stage: -1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
  2 Read Groups:
  Group #0
    x385 = SRAMRead(x324,List(b28),Set()) rd{0}
     b28    c  mod
       1    0    0rd
  Group #1
    x391 = SRAMRead(x324,List(b81),Set()) rd{0}
     b81    c  mod
       1    0    0rd
  Grouping 1 Writes: 
    Access: x387 {0} [x388 (stage: 1)]
  1 Write Groups:
  Group #0
    x387 = SRAMWrite(x324,x386,List(b28),Set()) wr{0}
     b28    c  mod
       1    0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x385 {0}: 
      x387 {0}
    x385 <-> x387: LCA: x388 (stage: 1), coarse-dist: <None>
    x387 <-> x387: LCA: x388 (stage: 1), coarse-dist: <None>
  Dephasing Iters: x385 = SRAMRead(x324,List(b28),Set()) rd{0}
 b28    c  mod
   1    0    0rd -> x388
  Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: ListBuffer(b28)
  Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: List(0)
  Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: List(0)
  General read dephasing rules for x324: (b28,List(0)) -> (b28,0)
  Dephasing Iters: x387 = SRAMWrite(x324,x386,List(b28),Set()) wr{0}
 b28    c  mod
   1    0    0wr -> x388
  Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: ListBuffer(b28)
  Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: List(0)
  Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: List(0)
  General write dephasing rules for x324: (b28,List(0)) -> (b28,0)
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x385 = SRAMRead(x324,List(b28),Set()) rd{0}
 b28    c  mod
   1    0    0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x388: OpMemReduce (1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
    x385: SRAMRead
    x387: SRAMWrite
  **************************************************************************************
  Analyzing costs for banking schemes found for accum (x324)
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.6759859418661596 (SRAM LUTs: 0.008771929824561403%, FFs: 5.473453749315818E-4%, BRAMs: 0.6666666666666666%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 0.6759859418661596 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x385 = SRAMRead(x324,List(b28),Set()) rd{0}
      grp 0:  b28    c  mod
      grp 0:    1    0    0rd
    Writes:
      grp 0: x387 = SRAMWrite(x324,x386,List(b28),Set()) wr{0}
      grp 0:  b28    c  mod
      grp 0:    1    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    Buffer
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x387 = SRAMWrite(x324,x386,List(b28),Set()) {0}
      - ProjectTemplate.scala:49:10: }{_+_}
      - Scope: x388 (scope: 1, 3)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x385 = SRAMRead(x324,List(b28),Set()) {0}
      - ProjectTemplate.scala:49:10: }{_+_}
      - Scope: x388 (scope: 1, 1)))
  Result: Created instance #0
Group #1: 
    Preceding writes for x391 {0}: 
      x387 {0}
    x391 <-> x387: LCA: x396 (stage: -1), coarse-dist: 1
    x387 <-> x387: LCA: x388 (stage: 1), coarse-dist: <None>
  x391 <-> x387 # LCA: x396 (stage: -1), Dist: Some(1)
  x387 <-> x387 # LCA: x396 (stage: -1), Dist: Some(0)
  Dephasing Iters: x391 = SRAMRead(x324,List(b81),Set()) rd{0}
 b81    c  mod
   1    0    0rd -> x395
  Leaf: x395, Iters: ListBuffer(b81), target: x395, elements: ListBuffer(b81)
  Leaf: x395, Iters: ListBuffer(b81), target: x395, elements: List(0)
  Leaf: x395, Iters: ListBuffer(b81), target: x395, elements: List(0)
  General read dephasing rules for x324: (b81,List(0)) -> (b81,0)
  Dephasing Iters: x387 = SRAMWrite(x324,x386,List(b28),Set()) wr{0}
 b28    c  mod
   1    0    0wr -> x388
  Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: ListBuffer(b28)
  Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: List(0)
  Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: List(0)
  General write dephasing rules for x324: (b28,List(0)) -> (b28,0)
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x391 = SRAMRead(x324,List(b81),Set()) rd{0}
 b81    c  mod
   1    0    0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x396: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x388: OpMemReduce (1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
        x387: SRAMWrite
    x395: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x391: SRAMRead
  **************************************************************************************
  Analyzing costs for banking schemes found for accum (x324)
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 1.3519718837323191 (SRAM LUTs: 0.017543859649122806%, FFs: 0.0010946907498631637%, BRAMs: 1.3333333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 1.3519718837323191 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x391 = SRAMRead(x324,List(b81),Set()) rd{0}
      grp 0:  b81    c  mod
      grp 0:    1    0    0rd
    Writes:
      grp 0: x387 = SRAMWrite(x324,x386,List(b28),Set()) wr{0}
      grp 0:  b28    c  mod
      grp 0:    1    0    0wr
    Result: Right(List(<Banked>
Depth:    2
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: x396 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x387 = SRAMWrite(x324,x386,List(b28),Set()) {0}
      - ProjectTemplate.scala:49:10: }{_+_}
      - Scope: x388 (scope: 1, 3)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x391 = SRAMRead(x324,List(b81),Set()) {0}
      - ProjectTemplate.scala:51:35: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #1 with instance #0: 
    Computing overlaps: x391 = Some(SRAMRead(x324,List(b81),Set())) - x385 = Some(SRAMRead(x324,List(b28),Set()))
    Computing overlaps: x387 = Some(SRAMWrite(x324,x386,List(b28),Set())) - x387 = Some(SRAMWrite(x324,x386,List(b28),Set()))
    Dephasing Iters: x387 = SRAMWrite(x324,x386,List(b28),Set()) wr{0}
 b28    c  mod
   1    0    0wr -> x388
    Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: ListBuffer(b28)
    Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: List(0)
    Leaf: x388, Iters: ListBuffer(b28), target: x388, elements: List(0)
      x391 <-> x387: LCA: x396 (stage: -1), coarse-dist: 1
      x385 <-> x387: LCA: x388 (stage: 1), coarse-dist: <None>
      x387 <-> x387: LCA: x388 (stage: 1), coarse-dist: <None>
    Did not merge 1 into instance 0: Accumulator conflict (A Type: None, B Type: Buffer)
  Result: Created instance #1
---------------------------------------------------------------------
SUMMARY: 
Name: accum (x324)
Type: SRAM1[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:30:30
Src:  	  val accum = SRAM[T](3)
Symbol:     x324 = SRAMNew(List(Const(3)),SRAM1[Fix[TRUE,_10,_22]])
---------------------------------------------------------------------
Instances: 2
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    Buffer
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x387 = SRAMWrite(x324,x386,List(b28),Set()) {0}
        - ProjectTemplate.scala:49:10: }{_+_}
        - Scope: x388 (scope: 1, 3)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x385 = SRAMRead(x324,List(b28),Set()) {0}
        - ProjectTemplate.scala:49:10: }{_+_}
        - Scope: x388 (scope: 1, 1)



Instance #1
  <Banked>
  Depth:    2
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: x396 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x387 = SRAMWrite(x324,x386,List(b28),Set()) {0}
        - ProjectTemplate.scala:49:10: }{_+_}
        - Scope: x388 (scope: 1, 3)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x391 = SRAMRead(x324,List(b81),Set()) {0}
        - ProjectTemplate.scala:51:35: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
  M [Type:WR]:
  M [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x385 {0}
  Added dispatch 0 to x385 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x387 {0}
  Added dispatch 0 to x387 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x385 {0}
  Added dispatch 0 to x385 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x387 {0}
  Added dispatch 0 to x387 {0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x391 {0}
  Added dispatch 1 to x391 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x387 {0}
  Added dispatch 1 to x387 {0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x391 {0}
  Added dispatch 1 to x391 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x387 {0}
  Added dispatch 1 to x387 {0}
---------------------------------------------------------------------
INFERRING...
Name: x403
Type: Reg[Fix[TRUE,_32,_0]]
Src:  ProjectTemplate.scala:54:16
Src:        out_host store out_sram
Symbol:     x403 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x430 {0} [x437 (stage: -1)]
  1 Read Groups:
  Group #0
    x430 = RegRead(x403) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x422 {} [x424 (stage: -1)]
  1 Write Groups:
  Group #0
    x422 = RegWrite(x403,x410,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x430 {0}: 
      x422 {}
    x430 <-> x422: LCA: x438 (stage: -1), coarse-dist: <None>
    x422 <-> x422: LCA: x424 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x430 = RegRead(x403) rd{0}
   c  modrd -> x437
  Leaf: x437, Iters: ListBuffer(b195), target: x437, elements: ListBuffer(b195)
  Leaf: x437, Iters: ListBuffer(b195), target: x437, elements: List(0)
  Leaf: x437, Iters: ListBuffer(b195), target: x437, elements: List(0)
  General read dephasing rules for x403: (b195,List(0)) -> (b195,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x430 = RegRead(x403) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x438: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
    x424: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x422: RegWrite
    x437: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x430: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x403
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x430 = RegRead(x403) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x422 = RegWrite(x403,x410,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x422 = RegWrite(x403,x410,Set()) {}
      - ProjectTemplate.scala:54:16: out_host store out_sram
      - Scope: x424 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x430 = RegRead(x403) {0}
      - ProjectTemplate.scala:54:16: out_host store out_sram
      - Scope: x437 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x403
Type: Reg[Fix[TRUE,_32,_0]]
Src:  ProjectTemplate.scala:54:16
Src:        out_host store out_sram
Symbol:     x403 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x422 = RegWrite(x403,x410,Set()) {}
        - ProjectTemplate.scala:54:16: out_host store out_sram
        - Scope: x424 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x430 = RegRead(x403) {0}
        - ProjectTemplate.scala:54:16: out_host store out_sram
        - Scope: x437 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x430 {0}
  Added dispatch 0 to x430 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x422 {}
  Added dispatch 0 to x422 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x430 {0}
  Added dispatch 0 to x430 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x422 {}
  Added dispatch 0 to x422 {}
---------------------------------------------------------------------
INFERRING...
Name: x398
Type: StreamOut[Tup2[Fix[TRUE,_10,_22],Bit]]
Src:  ProjectTemplate.scala:54:16
Src:        out_host store out_sram
Symbol:     x398 = StreamOutNew(BurstFullDataBus())
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 0 Reads: 

  <No Read Groups>
  Grouping 1 Writes: 
    Access: x436 {0,0} [x437 (stage: -1)]
  1 Write Groups:
  Group #0
    x436 = StreamOutWrite(x398,x435,Set()) wr{0,0}
     b256  b195     c   mod
        1     1     0     0wr
  x436 <-> x436: LCA: x437 (stage: -1), coarse-dist: <None>
Dephasing Iters: x436 = StreamOutWrite(x398,x435,Set()) wr{0,0}
 b256  b195     c   mod
    1     1     0     0wr -> x437
Leaf: x437, Iters: ListBuffer(b256, b195), target: x442, elements: ListBuffer(b256, b195)
Leaf: x437, Iters: ListBuffer(b256, b195), target: x442, elements: List(0, 0)
Leaf: x437, Iters: ListBuffer(b256, b195), target: x442, elements: List(0, 0)
General write dephasing rules for x398: (b256,List(0, 0)) -> (b256,0)
  - (b195,List(0, 0)) -> (b195,0)
solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
x437: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
  x436: StreamOutWrite
**************************************************************************************
Analyzing costs for banking schemes found for x398
Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
  - 0 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
          Access Hist:
          | width | R | W |
          | 1 | 0 | 1 |
        - Duplicate costs 0.0 (LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
***** Cost summary *****
Cost: 0.0 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
**************************************************************************************
  Reads:
  Writes:
    grp 0: x436 = StreamOutWrite(x398,x435,Set()) wr{0,0}
    grp 0:  b256  b195     c   mod
    grp 0:     1     1     0     0wr
  Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x436 = StreamOutWrite(x398,x435,Set()) {0,0}
      - ProjectTemplate.scala:54:16: out_host store out_sram
      - Scope: x437 (scope: 0, 0)
0 [Type:RD]:))
---------------------------------------------------------------------
SUMMARY: 
Name: x398
Type: StreamOut[Tup2[Fix[TRUE,_10,_22],Bit]]
Src:  ProjectTemplate.scala:54:16
Src:        out_host store out_sram
Symbol:     x398 = StreamOutNew(BurstFullDataBus())
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x436 = StreamOutWrite(x398,x435,Set()) {0,0}
        - ProjectTemplate.scala:54:16: out_host store out_sram
        - Scope: x437 (scope: 0, 0)
  0 [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x436 {0,0}
  Added dispatch 0 to x436 {0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x436 {0,0}
  Added dispatch 0 to x436 {0,0}
---------------------------------------------------------------------
INFERRING...
Name: x298
Type: Reg[Fix[TRUE,_32,_0]]
Src:  ProjectTemplate.scala:21:14
Src:        A_sram load A_dram
Symbol:     x298 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x307 {} [x318 (stage: -1)]
  1 Read Groups:
  Group #0
    x307 = RegRead(x298) rd{}
       c  modrd
  Grouping 1 Writes: 
    Access: x305 {} [x306 (stage: -1)]
  1 Write Groups:
  Group #0
    x305 = RegWrite(x298,x304,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x307 {}: 
      x305 {}
    x307 <-> x305: LCA: x319 (stage: -1), coarse-dist: <None>
    x305 <-> x305: LCA: x306 (stage: -1), coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x307 = RegRead(x298) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x319: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    x306: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x305: RegWrite
    x318: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x307: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x298
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x307 = RegRead(x298) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x305 = RegWrite(x298,x304,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x305 = RegWrite(x298,x304,Set()) {}
      - ProjectTemplate.scala:21:14: A_sram load A_dram
      - Scope: x306 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x307 = RegRead(x298) {}
      - ProjectTemplate.scala:21:14: A_sram load A_dram
      - Scope: x318 (scope: -1, -1)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x298
Type: Reg[Fix[TRUE,_32,_0]]
Src:  ProjectTemplate.scala:21:14
Src:        A_sram load A_dram
Symbol:     x298 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x305 = RegWrite(x298,x304,Set()) {}
        - ProjectTemplate.scala:21:14: A_sram load A_dram
        - Scope: x306 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x307 = RegRead(x298) {}
        - ProjectTemplate.scala:21:14: A_sram load A_dram
        - Scope: x318 (scope: -1, -1)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x307 {}
  Added dispatch 0 to x307 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x305 {}
  Added dispatch 0 to x305 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x307 {}
  Added dispatch 0 to x307 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x305 {}
  Added dispatch 0 to x305 {}
---------------------------------------------------------------------
INFERRING...
Name: x296
Type: Reg[Fix[TRUE,_32,_0]]
Src:  ProjectTemplate.scala:21:14
Src:        A_sram load A_dram
Symbol:     x296 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x310 {0} [x318 (stage: -1)]
  1 Read Groups:
  Group #0
    x310 = RegRead(x296) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x301 {} [x306 (stage: -1)]
  1 Write Groups:
  Group #0
    x301 = RegWrite(x296,x300,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x310 {0}: 
      x301 {}
    x310 <-> x301: LCA: x319 (stage: -1), coarse-dist: <None>
    x301 <-> x301: LCA: x306 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x310 = RegRead(x296) rd{0}
   c  modrd -> x318
  Leaf: x318, Iters: ListBuffer(b146), target: x318, elements: ListBuffer(b146)
  Leaf: x318, Iters: ListBuffer(b146), target: x318, elements: List(0)
  Leaf: x318, Iters: ListBuffer(b146), target: x318, elements: List(0)
  General read dephasing rules for x296: (b146,List(0)) -> (b146,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x310 = RegRead(x296) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x319: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    x306: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x301: RegWrite
    x318: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x310: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x296
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x310 = RegRead(x296) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x301 = RegWrite(x296,x300,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x301 = RegWrite(x296,x300,Set()) {}
      - ProjectTemplate.scala:21:14: A_sram load A_dram
      - Scope: x306 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x310 = RegRead(x296) {0}
      - ProjectTemplate.scala:21:14: A_sram load A_dram
      - Scope: x318 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x296
Type: Reg[Fix[TRUE,_32,_0]]
Src:  ProjectTemplate.scala:21:14
Src:        A_sram load A_dram
Symbol:     x296 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x301 = RegWrite(x296,x300,Set()) {}
        - ProjectTemplate.scala:21:14: A_sram load A_dram
        - Scope: x306 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x310 = RegRead(x296) {0}
        - ProjectTemplate.scala:21:14: A_sram load A_dram
        - Scope: x318 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x310 {0}
  Added dispatch 0 to x310 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x301 {}
  Added dispatch 0 to x301 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x310 {0}
  Added dispatch 0 to x310 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x301 {}
  Added dispatch 0 to x301 {}
---------------------------------------------------------------------
INFERRING...
Name: x402
Type: Reg[Fix[TRUE,_32,_0]]
Src:  ProjectTemplate.scala:54:16
Src:        out_host store out_sram
Symbol:     x402 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x428 {0} [x437 (stage: -1)]
  1 Read Groups:
  Group #0
    x428 = RegRead(x402) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x421 {} [x424 (stage: -1)]
  1 Write Groups:
  Group #0
    x421 = RegWrite(x402,x409,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x428 {0}: 
      x421 {}
    x428 <-> x421: LCA: x438 (stage: -1), coarse-dist: <None>
    x421 <-> x421: LCA: x424 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x428 = RegRead(x402) rd{0}
   c  modrd -> x437
  Leaf: x437, Iters: ListBuffer(b195), target: x437, elements: ListBuffer(b195)
  Leaf: x437, Iters: ListBuffer(b195), target: x437, elements: List(0)
  Leaf: x437, Iters: ListBuffer(b195), target: x437, elements: List(0)
  General read dephasing rules for x402: (b195,List(0)) -> (b195,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x428 = RegRead(x402) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x438: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
    x424: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x421: RegWrite
    x437: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x428: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x402
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x428 = RegRead(x402) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x421 = RegWrite(x402,x409,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x421 = RegWrite(x402,x409,Set()) {}
      - ProjectTemplate.scala:54:16: out_host store out_sram
      - Scope: x424 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x428 = RegRead(x402) {0}
      - ProjectTemplate.scala:54:16: out_host store out_sram
      - Scope: x437 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x402
Type: Reg[Fix[TRUE,_32,_0]]
Src:  ProjectTemplate.scala:54:16
Src:        out_host store out_sram
Symbol:     x402 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x421 = RegWrite(x402,x409,Set()) {}
        - ProjectTemplate.scala:54:16: out_host store out_sram
        - Scope: x424 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x428 = RegRead(x402) {0}
        - ProjectTemplate.scala:54:16: out_host store out_sram
        - Scope: x437 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x428 {0}
  Added dispatch 0 to x428 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x421 {}
  Added dispatch 0 to x421 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x428 {0}
  Added dispatch 0 to x428 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x421 {}
  Added dispatch 0 to x421 {}
---------------------------------------------------------------------
INFERRING...
Name: x350
Type: Reg[Bit]
Src:  ProjectTemplate.scala:44:24
Src:  	    force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)
Symbol:     x350 = RegNew(Const(false))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x359 {} [x373 (stage: -1)]
  1 Read Groups:
  Group #0
    x359 = RegRead(x350) rd{}
       c  modrd
  Grouping 1 Writes: 
    Access: x357 {} [x358 (stage: -1)]
  1 Write Groups:
  Group #0
    x357 = RegWrite(x350,x355,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x359 {}: 
      x357 {}
    x359 <-> x357: LCA: x388 (stage: -1), coarse-dist: 1
    x357 <-> x357: LCA: x358 (stage: -1), coarse-dist: <None>
  x359 <-> x357 # LCA: x388 (stage: -1), Dist: Some(1)
  x357 <-> x357 # LCA: x388 (stage: -1), Dist: Some(0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x359 = RegRead(x350) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x358: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x357: RegWrite
    x373: Switch (-1) [Level: InnerControl, Loop: Single, Schedule: Fork]
      x359: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x350
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.45065729457743975 (LUTs: 0.005847953216374269%, FFs: 3.6489691662105453E-4%, BRAMs: 0.4444444444444444%)
  ***** Cost summary *****
  Cost: 0.45065729457743975 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x359 = RegRead(x350) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x357 = RegWrite(x350,x355,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    2
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x388 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x357 = RegWrite(x350,x355,Set()) {}
      - ProjectTemplate.scala:44:24: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
      - Scope: x358 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x359 = RegRead(x350) {}
      - ProjectTemplate.scala:44:24: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
      - Scope: x373 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x350
Type: Reg[Bit]
Src:  ProjectTemplate.scala:44:24
Src:  	    force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)
Symbol:     x350 = RegNew(Const(false))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    2
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: x388 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x357 = RegWrite(x350,x355,Set()) {}
        - ProjectTemplate.scala:44:24: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
        - Scope: x358 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x359 = RegRead(x350) {}
        - ProjectTemplate.scala:44:24: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}(Pass 28)(Pass 28)
        - Scope: x373 (scope: -1, -1)
  M [Type:WR]:
  M [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(1),0,0,List(0),List(0)) to x359 {}
  Added dispatch 0 to x359 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x357 {}
  Added dispatch 0 to x357 {}
  Added port Port(Some(1),0,0,List(0),List(0)) to x359 {}
  Added dispatch 0 to x359 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x357 {}
  Added dispatch 0 to x357 {}
---------------------------------------------------------------------
INFERRING...
Name: x271
Type: StreamIn[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:21:14
Src:        A_sram load A_dram
Symbol:     x271 = StreamInNew(BurstDataBus())
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x316 {0,0} [x318 (stage: -1)]
  1 Read Groups:
  Group #0
    x316 = StreamInRead(x271,Set()) rd{0,0}
     b251  b146     c   mod
        1     1     0     0rd
  Grouping 0 Reads: 

  <No Read Groups>



Merging memory instance groups:
Group #0: 
    Preceding writes for x316 {0,0}: 
  Dephasing Iters: x316 = StreamInRead(x271,Set()) rd{0,0}
 b251  b146     c   mod
    1     1     0     0rd -> x318
  Leaf: x318, Iters: ListBuffer(b251, b146), target: x319, elements: ListBuffer(b251, b146)
  Leaf: x318, Iters: ListBuffer(b251, b146), target: x319, elements: List(0, 0)
  Leaf: x318, Iters: ListBuffer(b251, b146), target: x319, elements: List(0, 0)
  General read dephasing rules for x271: (b251,List(0, 0)) -> (b251,0)
  - (b146,List(0, 0)) -> (b146,0)
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x316 = StreamInRead(x271,Set()) rd{0,0}
 b251  b146     c   mod
    1     1     0     0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x318: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
    x316: StreamInRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x271
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 0 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x316 = StreamInRead(x271,Set()) rd{0,0}
      grp 0:  b251  b146     c   mod
      grp 0:     1     1     0     0rd
    Writes:
    Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x316 = StreamInRead(x271,Set()) {0,0}
      - ProjectTemplate.scala:21:14: A_sram load A_dram
      - Scope: x318 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x271
Type: StreamIn[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:21:14
Src:        A_sram load A_dram
Symbol:     x271 = StreamInNew(BurstDataBus())
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x316 = StreamInRead(x271,Set()) {0,0}
        - ProjectTemplate.scala:21:14: A_sram load A_dram
        - Scope: x318 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x316 {0,0}
  Added dispatch 0 to x316 {0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x316 {0,0}
  Added dispatch 0 to x316 {0,0}
---------------------------------------------------------------------
INFERRING...
Name: x399
Type: StreamIn[Bit]
Src:  ProjectTemplate.scala:54:16
Src:        out_host store out_sram
Symbol:     x399 = StreamInNew(BurstAckBus)
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x440 {0} [x441 (stage: -1)]
  1 Read Groups:
  Group #0
    x440 = StreamInRead(x399,Set()) rd{0}
     b256     c   mod
        1     0     0rd
  Grouping 0 Reads: 

  <No Read Groups>



Merging memory instance groups:
Group #0: 
    Preceding writes for x440 {0}: 
  Dephasing Iters: x440 = StreamInRead(x399,Set()) rd{0}
 b256     c   mod
    1     0     0rd -> x441
  Leaf: x441, Iters: ListBuffer(b256), target: x442, elements: ListBuffer(b256)
  Current: x441
  Leaf: x441, Iters: ListBuffer(b256), target: x442, elements: List(0)
  Current: x441
  Leaf: x441, Iters: ListBuffer(b256), target: x442, elements: List(0)
  Current: x441
  General read dephasing rules for x399: (b256,List(0)) -> (b256,0)
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x440 = StreamInRead(x399,Set()) rd{0}
 b256     c   mod
    1     0     0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x441: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
    x440: StreamInRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x399
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 0 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x440 = StreamInRead(x399,Set()) rd{0}
      grp 0:  b256     c   mod
      grp 0:     1     0     0rd
    Writes:
    Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x440 = StreamInRead(x399,Set()) {0}
      - ProjectTemplate.scala:54:16: out_host store out_sram
      - Scope: x441 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x399
Type: StreamIn[Bit]
Src:  ProjectTemplate.scala:54:16
Src:        out_host store out_sram
Symbol:     x399 = StreamInNew(BurstAckBus)
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x440 = StreamInRead(x399,Set()) {0}
        - ProjectTemplate.scala:54:16: out_host store out_sram
        - Scope: x441 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x440 {0}
  Added dispatch 0 to x440 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x440 {0}
  Added dispatch 0 to x440 {0}
---------------------------------------------------------------------
INFERRING...
Name: A_sram (x268)
Type: SRAM2[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:19:27
Src:        val A_sram = SRAM[T](N, 3)
Symbol:     x268 = SRAMNew(List(Const(100), Const(3)),SRAM2[Fix[TRUE,_10,_22]])
Effort:    1
BankingViews:   List(Flat(2), Hierarchical(2,None))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()), RegroupDims(List(0)), RegroupDims(List(1)), RegroupDims(List(0, 1)))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 50 Reads: 
    Access: x332 {0,0,0} [x336 (stage: -1)]
    Access: x332 {0,1,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,1,0}
 b20  b33    c  mod
  10    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,1,0}
 b20  b33    c  mod
  10    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <1 accesses>
    Access: x332 {1,0,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,0,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,0,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <2 accesses>
    Access: x332 {1,1,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,1,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,1,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,1,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,1,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <3 accesses>
    Access: x332 {2,0,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,0,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,0,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,0,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,0,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <4 accesses>
    Access: x332 {2,1,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <5 accesses>
    Access: x332 {3,0,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,0,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,0,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,0,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,0,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,0,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,0,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <6 accesses>
    Access: x332 {3,1,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <7 accesses>
    Access: x332 {4,0,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <8 accesses>
    Access: x332 {4,1,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <9 accesses>
    Access: x332 {5,0,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <10 accesses>
    Access: x332 {5,1,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <11 accesses>
    Access: x332 {6,0,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <12 accesses>
    Access: x332 {6,1,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <13 accesses>
    Access: x332 {7,0,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <14 accesses>
    Access: x332 {7,1,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <15 accesses>
    Access: x332 {8,0,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <16 accesses>
    Access: x332 {8,1,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <17 accesses>
    Access: x332 {9,0,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <18 accesses>
    Access: x332 {9,1,0} [x336 (stage: -1)]
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x332 = Some(SRAMRead(x268,List(b20, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <none>
      Group #0 same port: <19 accesses>
    Access: x333 {0,0,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
    Access: x333 {0,1,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <1 accesses>
    Access: x333 {1,0,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <2 accesses>
    Access: x333 {1,1,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <3 accesses>
    Access: x333 {2,0,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <4 accesses>
    Access: x333 {2,1,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <5 accesses>
    Access: x333 {3,0,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <6 accesses>
    Access: x333 {3,1,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <7 accesses>
    Access: x333 {4,0,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <8 accesses>
    Access: x333 {4,1,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <9 accesses>
    Access: x333 {5,0,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <10 accesses>
    Access: x333 {5,1,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <11 accesses>
    Access: x333 {6,0,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <12 accesses>
    Access: x333 {6,1,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <13 accesses>
    Access: x333 {7,0,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <14 accesses>
    Access: x333 {7,1,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <15 accesses>
    Access: x333 {8,0,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <16 accesses>
    Access: x333 {8,1,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <17 accesses>
    Access: x333 {9,0,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <18 accesses>
    Access: x333 {9,1,0} [x336 (stage: -1)]
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
      Group #0 conflicts: <10 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
      Group #1 conflicts: <none>
      Group #1 same port: <19 accesses>
    Access: x392 {0,0} [x395 (stage: -1)]
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
      Group #0 conflicts: <2 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
      Group #1 conflicts: <10 accesses>
      Group #1 same port: <20 accesses>
    Access: x392 {1,0} [x395 (stage: -1)]
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
      Group #0 conflicts: <2 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
      Group #1 conflicts: <10 accesses>
      Group #1 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{1,0}
 b20  b81    c  mod
  10    0    1    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
      Group #2 conflicts: <none>
      Group #2 same port: <1 accesses>
    Access: x392 {2,0} [x395 (stage: -1)]
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
      Group #0 conflicts: <2 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
      Group #1 conflicts: <10 accesses>
      Group #1 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{2,0}
 b20  b81    c  mod
  10    0    2    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{2,0}
 b20  b81    c  mod
  10    0    2    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
      Group #2 conflicts: <none>
      Group #2 same port: <2 accesses>
    Access: x392 {3,0} [x395 (stage: -1)]
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
      Group #0 conflicts: <2 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
      Group #1 conflicts: <10 accesses>
      Group #1 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{3,0}
 b20  b81    c  mod
  10    0    3    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{3,0}
 b20  b81    c  mod
  10    0    3    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{3,0}
 b20  b81    c  mod
  10    0    3    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
      Group #2 conflicts: <none>
      Group #2 same port: <3 accesses>
    Access: x392 {4,0} [x395 (stage: -1)]
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
      Group #0 conflicts: <2 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
      Group #1 conflicts: <10 accesses>
      Group #1 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
      Group #2 conflicts: <none>
      Group #2 same port: <4 accesses>
    Access: x392 {5,0} [x395 (stage: -1)]
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
      Group #0 conflicts: <2 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
      Group #1 conflicts: <10 accesses>
      Group #1 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
      Group #2 conflicts: <none>
      Group #2 same port: <5 accesses>
    Access: x392 {6,0} [x395 (stage: -1)]
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
      Group #0 conflicts: <2 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
      Group #1 conflicts: <10 accesses>
      Group #1 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
      Group #2 conflicts: <none>
      Group #2 same port: <6 accesses>
    Access: x392 {7,0} [x395 (stage: -1)]
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
      Group #0 conflicts: <2 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
      Group #1 conflicts: <10 accesses>
      Group #1 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
      Group #2 conflicts: <none>
      Group #2 same port: <7 accesses>
    Access: x392 {8,0} [x395 (stage: -1)]
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
      Group #0 conflicts: <2 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
      Group #1 conflicts: <10 accesses>
      Group #1 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
      Group #2 conflicts: <none>
      Group #2 same port: <8 accesses>
    Access: x392 {9,0} [x395 (stage: -1)]
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
      Group #0 conflicts: <2 accesses>
      Group #0 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
      Group #1 conflicts: <10 accesses>
      Group #1 same port: <20 accesses>
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x392 = Some(SRAMRead(x268,List(b20, b81),Set()))
Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd -> x395
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
      Group #2 conflicts: <none>
      Group #2 same port: <9 accesses>
  3 Read Groups:
  Group #0
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,1,0}
     b20  b33    c  mod
      10    0    0    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
     b20  b33    c  mod
      10    0    4    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
     b20  b33    c  mod
      10    0    7    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
     b20  b33    c  mod
      10    0    3    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
     b20  b33    c  mod
      10    0    2    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,0,0}
     b20  b33    c  mod
      10    0    1    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
     b20  b33    c  mod
      10    0    8    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
     b20  b33    c  mod
      10    0    6    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
     b20  b33    c  mod
      10    0    9    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
     b20  b33    c  mod
      10    0    9    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,0,0}
     b20  b33    c  mod
      10    0    0    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,0,0}
     b20  b33    c  mod
      10    0    2    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,0,0}
     b20  b33    c  mod
      10    0    3    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
     b20  b33    c  mod
      10    0    8    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,1,0}
     b20  b33    c  mod
      10    0    1    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
     b20  b33    c  mod
      10    0    4    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
     b20  b33    c  mod
      10    0    6    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
     b20  b33    c  mod
      10    0    5    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
     b20  b33    c  mod
      10    0    7    0
       0    1    0    0rd
    x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
     b20  b33    c  mod
      10    0    5    0
       0    1    0    0rd
  Group #1
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
     b27  b33    c  mod
       2    0    0    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
     b27  b33    c  mod
       2    0    0    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
     b27  b33    c  mod
       2    0    0    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
     b27  b33    c  mod
       2    0    1    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
     b27  b33    c  mod
       2    0    1    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
     b27  b33    c  mod
       2    0    0    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
     b27  b33    c  mod
       2    0    0    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
     b27  b33    c  mod
       2    0    0    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
     b27  b33    c  mod
       2    0    1    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
     b27  b33    c  mod
       2    0    1    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
     b27  b33    c  mod
       2    0    0    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
     b27  b33    c  mod
       2    0    1    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
     b27  b33    c  mod
       2    0    1    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
     b27  b33    c  mod
       2    0    1    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
     b27  b33    c  mod
       2    0    1    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
     b27  b33    c  mod
       2    0    1    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
     b27  b33    c  mod
       2    0    0    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
     b27  b33    c  mod
       2    0    0    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
     b27  b33    c  mod
       2    0    1    0
       0    1    0    0rd
    x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
     b27  b33    c  mod
       2    0    0    0
       0    1    0    0rd
  Group #2
    x392 = SRAMRead(x268,List(b20, b81),Set()) rd{4,0}
     b20  b81    c  mod
      10    0    4    0
       0    1    0    0rd
    x392 = SRAMRead(x268,List(b20, b81),Set()) rd{6,0}
     b20  b81    c  mod
      10    0    6    0
       0    1    0    0rd
    x392 = SRAMRead(x268,List(b20, b81),Set()) rd{0,0}
     b20  b81    c  mod
      10    0    0    0
       0    1    0    0rd
    x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
     b20  b81    c  mod
      10    0    8    0
       0    1    0    0rd
    x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
     b20  b81    c  mod
      10    0    7    0
       0    1    0    0rd
    x392 = SRAMRead(x268,List(b20, b81),Set()) rd{3,0}
     b20  b81    c  mod
      10    0    3    0
       0    1    0    0rd
    x392 = SRAMRead(x268,List(b20, b81),Set()) rd{5,0}
     b20  b81    c  mod
      10    0    5    0
       0    1    0    0rd
    x392 = SRAMRead(x268,List(b20, b81),Set()) rd{1,0}
     b20  b81    c  mod
      10    0    1    0
       0    1    0    0rd
    x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
     b20  b81    c  mod
      10    0    9    0
       0    1    0    0rd
    x392 = SRAMRead(x268,List(b20, b81),Set()) rd{2,0}
     b20  b81    c  mod
      10    0    2    0
       0    1    0    0rd
  Grouping 1 Writes: 
    Access: x317 {0,0} [x318 (stage: -1)]
  1 Write Groups:
  Group #0
    x317 = SRAMWrite(x268,x316,List(b251, x315),Set(x314)) wr{0,0}
     b251  b146  b460     c   mod
        1     0     0     0     0
        0     1    -1     0     0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x332 {0,1,0}: 
      x317 {0,0}
    Preceding writes for x332 {4,1,0}: 
    Preceding writes for x332 {7,1,0}: 
    Preceding writes for x332 {3,1,0}: 
    Preceding writes for x332 {2,1,0}: 
    Preceding writes for x332 {1,0,0}: 
    Preceding writes for x332 {8,0,0}: 
    Preceding writes for x332 {6,0,0}: 
    Preceding writes for x332 {9,0,0}: 
    Preceding writes for x332 {9,1,0}: 
    Preceding writes for x332 {0,0,0}: 
    Preceding writes for x332 {2,0,0}: 
    Preceding writes for x332 {3,0,0}: 
    Preceding writes for x332 {8,1,0}: 
    Preceding writes for x332 {1,1,0}: 
    Preceding writes for x332 {4,0,0}: 
    Preceding writes for x332 {6,1,0}: 
    Preceding writes for x332 {5,0,0}: 
    Preceding writes for x332 {7,0,0}: 
    Preceding writes for x332 {5,1,0}: 
    x317 <-> x317: LCA: x318 (stage: -1), coarse-dist: <None>
    x332 <-> x317: LCA: x444 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,1,0}
 b20  b33    c  mod
  10    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,0,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,0,0}
 b20  b33    c  mod
  10    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,0,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,0,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,1,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  General read dephasing rules for x268: (b33,List(1, 1, 0)) -> (b33,0)
  - (b20,List(5, 1, 0)) -> (b20,0)
  - (b27,List(5, 1, 0)) -> (b27,0)
  - (b20,List(9, 1, 0)) -> (b20,0)
  - (b33,List(8, 0, 0)) -> (b33,0)
  - (b20,List(2, 1, 0)) -> (b20,0)
  - (b33,List(0, 0, 0)) -> (b33,0)
  - (b20,List(3, 1, 0)) -> (b20,0)
  - (b33,List(7, 0, 0)) -> (b33,0)
  - (b27,List(0, 1, 0)) -> (b27,0)
  - (b27,List(3, 1, 0)) -> (b27,0)
  - (b20,List(4, 1, 0)) -> (b20,0)
  - (b20,List(0, 0, 0)) -> (b20,0)
  - (b33,List(2, 0, 0)) -> (b33,0)
  - (b27,List(0, 0, 0)) -> (b27,0)
  - (b33,List(1, 0, 0)) -> (b33,0)
  - (b33,List(2, 1, 0)) -> (b33,0)
  - (b27,List(7, 0, 0)) -> (b27,0)
  - (b27,List(1, 1, 0)) -> (b27,0)
  - (b27,List(7, 1, 0)) -> (b27,0)
  - (b27,List(2, 1, 0)) -> (b27,0)
  - (b33,List(4, 1, 0)) -> (b33,0)
  - (b20,List(6, 0, 0)) -> (b20,0)
  - (b27,List(9, 0, 0)) -> (b27,0)
  - (b20,List(2, 0, 0)) -> (b20,0)
  - (b33,List(5, 1, 0)) -> (b33,0)
  - (b27,List(9, 1, 0)) -> (b27,0)
  - (b27,List(8, 0, 0)) -> (b27,0)
  - (b20,List(4, 0, 0)) -> (b20,0)
  - (b27,List(6, 1, 0)) -> (b27,0)
  - (b27,List(4, 1, 0)) -> (b27,0)
  - (b33,List(9, 1, 0)) -> (b33,0)
  - (b27,List(8, 1, 0)) -> (b27,0)
  - (b33,List(9, 0, 0)) -> (b33,0)
  - (b27,List(6, 0, 0)) -> (b27,0)
  - (b20,List(9, 0, 0)) -> (b20,0)
  - (b20,List(7, 0, 0)) -> (b20,0)
  - (b20,List(8, 0, 0)) -> (b20,0)
  - (b33,List(3, 0, 0)) -> (b33,0)
  - (b33,List(5, 0, 0)) -> (b33,0)
  - (b27,List(3, 0, 0)) -> (b27,0)
  - (b20,List(5, 0, 0)) -> (b20,0)
  - (b33,List(4, 0, 0)) -> (b33,0)
  - (b33,List(8, 1, 0)) -> (b33,0)
  - (b33,List(6, 1, 0)) -> (b33,0)
  - (b20,List(6, 1, 0)) -> (b20,0)
  - (b27,List(2, 0, 0)) -> (b27,0)
  - (b20,List(8, 1, 0)) -> (b20,0)
  - (b20,List(1, 1, 0)) -> (b20,0)
  - (b33,List(0, 1, 0)) -> (b33,0)
  - (b20,List(1, 0, 0)) -> (b20,0)
  - (b33,List(3, 1, 0)) -> (b33,0)
  - (b20,List(7, 1, 0)) -> (b20,0)
  - (b27,List(1, 0, 0)) -> (b27,0)
  - (b27,List(5, 0, 0)) -> (b27,0)
  - (b33,List(7, 1, 0)) -> (b33,0)
  - (b27,List(4, 0, 0)) -> (b27,0)
  - (b20,List(3, 0, 0)) -> (b20,0)
  - (b33,List(6, 0, 0)) -> (b33,0)
  - (b20,List(0, 1, 0)) -> (b20,0)
  Dephasing Iters: x317 = SRAMWrite(x268,x316,List(b251, x315),Set(x314)) wr{0,0}
 b251  b146  b460     c   mod
    1     0     0     0     0
    0     1    -1     0     0wr -> x318
  Leaf: x318, Iters: ListBuffer(b251, b146), target: x319, elements: ListBuffer(b251, b146)
  Leaf: x318, Iters: ListBuffer(b251, b146), target: x319, elements: List(0, 0)
  Leaf: x318, Iters: ListBuffer(b251, b146), target: x319, elements: List(0, 0)
  General write dephasing rules for x268: (b251,List(0, 0)) -> (b251,0)
  - (b146,List(0, 0)) -> (b146,0)
  Finding scheme for BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Original banking group #0 has (1 accesses)
       b251     c   mod
          1     0     0wr
  Original banking group #1 has (10 accesses)
       b20    c  mod
        10    4    0rd
       b20    c  mod
        10    7    0rd
       b20    c  mod
        10    9    0rd
       b20    c  mod
        10    8    0rd
       b20    c  mod
        10    1    0rd
       b20    c  mod
        10    3    0rd
       b20    c  mod
        10    6    0rd
       b20    c  mod
        10    0    0rd
       b20    c  mod
        10    5    0rd
       b20    c  mod
        10    2    0rd
  Regrouped banking group #0 has (1 accesses)
       b251     c   mod
          1     0     0wr
  Regrouped banking group #1 has (10 accesses)
       b20    c  mod
        10    4    0rd
       b20    c  mod
        10    7    0rd
       b20    c  mod
        10    9    0rd
       b20    c  mod
        10    8    0rd
       b20    c  mod
        10    1    0rd
       b20    c  mod
        10    3    0rd
       b20    c  mod
        10    6    0rd
       b20    c  mod
        10    0    0rd
       b20    c  mod
        10    5    0rd
       b20    c  mod
        10    2    0rd
   Solution space: 11 * 16 * 11 (B), check complexity: 46
       Checking N=10 and alpha=List(0)
       Checking N=10 and alpha=List(1)
       Success on N=10, alpha=List(1), B=1
       Checking N=10 and alpha=List(2)
       Checking N=10 and alpha=List(3)
       Success on N=10, alpha=List(3), B=1
         x268: Found 2 solutions after 184 (= 4 * 46) attempts to find solution for NBestGuess AlphaBestGuess List(0)
  Original banking group #0 has (1 accesses)
       b146  b460     c   mod
          1    -1     0     0wr
  Original banking group #1 has (1 accesses)
       b33    c  mod
         1    0    0rd
  Regrouped banking group #0 has (1 accesses)
       b146  b460     c   mod
          1    -1     0     0wr
  Regrouped banking group #1 has (1 accesses)
       b33    c  mod
         1    0    0rd
  Banking scheme List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List()) to 1 
  Banking scheme List(Dims {0}: Cyclic: N=10, B=1, alpha=<3>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List()) to 2 
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(1)))
  Finding scheme for BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Original banking group #0 has (1 accesses)
       b251     c   mod
          1     0     0wr
  Regrouped banking group #0 has (1 accesses)
       b251     c   mod
          1     0     0wr
  Original banking group #0 has (1 accesses)
       b146  b460     c   mod
          1    -1     0     0wr
  Regrouped banking group #0 has (1 accesses)
       b146  b460     c   mod
          1    -1     0     0wr
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 1 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 2 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 3 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 4 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 5 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 6 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 7 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 8 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 9 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 10 
  Finding scheme for BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Original banking group #0 has (1 accesses)
       b251  b146  b460     c   mod
          1     0     0     0     0
          0     1    -1     0     0wr
  Original banking group #1 has (10 accesses)
       b20  b33    c  mod
        10    0    6    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    7    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    1    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    8    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    4    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    9    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    3    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    2    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    5    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    0    0
         0    1    0    0rd
  Regrouped banking group #0 has (1 accesses)
       b251  b146  b460     c   mod
          1     0     0     0     0
          0     1    -1     0     0wr
  Regrouped banking group #1 has (10 accesses)
       b20  b33    c  mod
        10    0    6    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    7    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    1    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    8    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    4    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    9    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    3    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    2    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    5    0
         0    1    0    0rd
       b20  b33    c  mod
        10    0    0    0
         0    1    0    0rd
   Solution space: 66 * 28 * 11 (B), check complexity: 46
       Checking N=10 and alpha=List(0, 0)
       Checking N=10 and alpha=List(0, 1)
       Checking N=10 and alpha=List(1, 0)
       Success on N=10, alpha=List(1, 0), B=1
       Checking N=10 and alpha=List(1, 1)
       Success on N=10, alpha=List(1, 1), B=1
         x268: Found 2 solutions after 184 (= 4 * 46) attempts to find solution for NBestGuess AlphaBestGuess List(0, 1)
  Banking scheme List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,0>, P=<10,1> (1848 solutions, 46 checks)) accepted!
  incrementing Flat(2), RegroupDims(List()) to 1 
  Banking scheme List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<1,10> (1848 solutions, 46 checks)) accepted!
  incrementing Flat(2), RegroupDims(List()) to 2 
  Banking scheme List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<10,1> (1848 solutions, 46 checks)) accepted!
  incrementing Flat(2), RegroupDims(List()) to 3 
  Finding scheme for BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Original banking group #0 has (1 accesses)
       b251  b146  b460     c   mod
          1     0     0     0     0
          0     1    -1     0     0wr
  Regrouped banking group #0 has (1 accesses)
       b251  b146  b460     c   mod
          1     0     0     0     0
          0     1    -1     0     0wr
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 1 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 2 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 3 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 4 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 5 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 6 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 7 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 8 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 9 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 10 
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List(1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List(1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List(1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NBestGuess,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NBestGuess,AlphaRelaxed,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaBestGuess,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaBestGuess,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaRelaxed,RegroupDims(List(0, 1)))
  solution bankings are Map(BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,1,0}
 b20  b33    c  mod
  10    0    0    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,0,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,0,0}
 b20  b33    c  mod
  10    0    0    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,0,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,0,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,1,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)), List(Dims {0}: Cyclic: N=10, B=1, alpha=<3>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))), BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) -> Map(Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,0,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,1,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,0,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,0,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,1,0}
 b20  b33    c  mod
  10    0    0    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,0,0}
 b20  b33    c  mod
  10    0    0    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))), BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,1,0}
 b20  b33    c  mod
  10    0    0    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,0,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,0,0}
 b20  b33    c  mod
  10    0    0    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,0,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,0,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,1,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,0>, P=<10,1> (1848 solutions, 46 checks)), List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<1,10> (1848 solutions, 46 checks)), List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<10,1> (1848 solutions, 46 checks)))), BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) -> Map(Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,0,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,1,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,0,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,0,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,1,0}
 b20  b33    c  mod
  10    0    0    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,0,0}
 b20  b33    c  mod
  10    0    0    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd, x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))))
  x444: AccelScope (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
    x320: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
      x319: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x318: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
          x317: SRAMWrite
    x396: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
        x336: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
          x332: SRAMRead
  **************************************************************************************
  Analyzing costs for banking schemes found for A_sram (x268)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 20 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 20 | 0 |
            | 10 | 0 | 1 |
          - Duplicate costs 330.33179692526335 (SRAM LUTs: 4.286549707602339%, FFs: 0.26746943988323296%, BRAMs: 325.77777777777777%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 1 instance 0:
    - 20 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=10, B=1, alpha=<3>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 20 | 0 |
            | 10 | 0 | 1 |
          - Duplicate costs 331.68376880899564 (SRAM LUTs: 4.304093567251462%, FFs: 0.26856413063309614%, BRAMs: 327.1111111111111%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 0:
    - 2 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 1:
    - 2 readers connect to duplicate #1 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 2:
    - 2 readers connect to duplicate #2 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 3:
    - 2 readers connect to duplicate #3 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 4:
    - 2 readers connect to duplicate #4 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 5:
    - 2 readers connect to duplicate #5 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 6:
    - 2 readers connect to duplicate #6 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 7:
    - 2 readers connect to duplicate #7 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 8:
    - 2 readers connect to duplicate #8 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 9:
    - 2 readers connect to duplicate #9 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 20 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,0>, P=<10,1> (1848 solutions, 46 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 20 | 0 |
            | 10 | 0 | 1 |
          - Duplicate costs 330.33179692526335 (SRAM LUTs: 4.286549707602339%, FFs: 0.26746943988323296%, BRAMs: 325.77777777777777%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 1 instance 0:
    - 20 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<1,10> (1848 solutions, 46 checks)))
            Access Hist:
            | width | R | W |
            | 10 | 20 | 1 |
          - Duplicate costs 3253.745666849115 (SRAM LUTs: 42.22222222222222%, FFs: 2.6345557380040137%, BRAMs: 3208.8888888888887%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 2 instance 0:
    - 20 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<10,1> (1848 solutions, 46 checks)))
            Access Hist:
            | width | R | W |
            | 10 | 20 | 1 |
          - Duplicate costs 3124.40702330539 (SRAM LUTs: 40.54385964912281%, FFs: 2.5298303229337713%, BRAMs: 3081.3333333333335%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 0:
    - 2 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 1:
    - 2 readers connect to duplicate #1 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 2:
    - 2 readers connect to duplicate #2 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 3:
    - 2 readers connect to duplicate #3 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 4:
    - 2 readers connect to duplicate #4 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 5:
    - 2 readers connect to duplicate #5 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 6:
    - 2 readers connect to duplicate #6 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 7:
    - 2 readers connect to duplicate #7 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 8:
    - 2 readers connect to duplicate #8 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 9:
    - 2 readers connect to duplicate #9 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 2 | 1 |
          - Duplicate costs 71.65450983781292 (SRAM LUTs: 0.9298245614035088%, FFs: 0.058018609742747675%, BRAMs: 70.66666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 330.33179692526335 for version 0 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 331.68376880899564 for version 1 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 716.5450983781294 for version 0 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Cost: 330.33179692526335 for version 0 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 3253.745666849115 for version 1 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 3124.40702330539 for version 2 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 716.5450983781294 for version 0 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  **************************************************************************************
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,1,0}
 b20  b33    c  mod
  10    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,1,0}
 b20  b33    c  mod
  10    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
 b20  b33    c  mod
  10    0    2    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
 b20  b33    c  mod
  10    0    3    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
 b20  b33    c  mod
  10    0    4    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
 b20  b33    c  mod
  10    0    5    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
 b20  b33    c  mod
  10    0    6    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
 b20  b33    c  mod
  10    0    7    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
 b20  b33    c  mod
  10    0    8    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
  Dephasing Iters: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
 b20  b33    c  mod
  10    0    9    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
    Reads:
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,1,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    0    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,1,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    4    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,1,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    7    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,1,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    3    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,1,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    2    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,0,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    1    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,0,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    8    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,0,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    6    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,0,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    9    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{9,1,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    9    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{0,0,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    0    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{2,0,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    2    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{3,0,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    3    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{8,1,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    8    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{1,1,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    1    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{4,0,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    4    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{6,1,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    6    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,0,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    5    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{7,0,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    7    0
      grp 0:    0    1    0    0rd
      grp 0: x332 = SRAMRead(x268,List(b20, b33),Set()) rd{5,1,0}
      grp 0:  b20  b33    c  mod
      grp 0:   10    0    5    0
      grp 0:    0    1    0    0rd
    Writes:
      grp 0: x317 = SRAMWrite(x268,x316,List(b251, x315),Set(x314)) wr{0,0}
      grp 0:  b251  b146  b460     c   mod
      grp 0:     1     0     0     0     0
      grp 0:     0     1    -1     0     0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List(0, 0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Hierarchical>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x317 = SRAMWrite(x268,x316,List(b251, x315),Set(x314)) {0,0}
      - ProjectTemplate.scala:21:14: A_sram load A_dram
      - Scope: x318 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x332 = SRAMRead(x268,List(b20, b33),Set()) {0,0,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 0] x332 = SRAMRead(x268,List(b20, b33),Set()) {0,1,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 1] x332 = SRAMRead(x268,List(b20, b33),Set()) {1,0,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 1] x332 = SRAMRead(x268,List(b20, b33),Set()) {1,1,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 2] x332 = SRAMRead(x268,List(b20, b33),Set()) {2,0,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 2] x332 = SRAMRead(x268,List(b20, b33),Set()) {2,1,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 3] x332 = SRAMRead(x268,List(b20, b33),Set()) {3,0,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 3] x332 = SRAMRead(x268,List(b20, b33),Set()) {3,1,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 4] x332 = SRAMRead(x268,List(b20, b33),Set()) {4,0,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 4] x332 = SRAMRead(x268,List(b20, b33),Set()) {4,1,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 5] x332 = SRAMRead(x268,List(b20, b33),Set()) {5,0,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 5] x332 = SRAMRead(x268,List(b20, b33),Set()) {5,1,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 6] x332 = SRAMRead(x268,List(b20, b33),Set()) {6,0,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 6] x332 = SRAMRead(x268,List(b20, b33),Set()) {6,1,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 7] x332 = SRAMRead(x268,List(b20, b33),Set()) {7,0,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 7] x332 = SRAMRead(x268,List(b20, b33),Set()) {7,1,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 8] x332 = SRAMRead(x268,List(b20, b33),Set()) {8,0,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 8] x332 = SRAMRead(x268,List(b20, b33),Set()) {8,1,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 9] x332 = SRAMRead(x268,List(b20, b33),Set()) {9,0,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 9] x332 = SRAMRead(x268,List(b20, b33),Set()) {9,1,0}
      - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)))
  Result: Created instance #0
Group #1: 
    Preceding writes for x333 {4,0,0}: 
      x317 {0,0}
    Preceding writes for x333 {5,0,0}: 
    Preceding writes for x333 {9,0,0}: 
    Preceding writes for x333 {4,1,0}: 
    Preceding writes for x333 {2,1,0}: 
    Preceding writes for x333 {3,0,0}: 
    Preceding writes for x333 {7,0,0}: 
    Preceding writes for x333 {1,0,0}: 
    Preceding writes for x333 {9,1,0}: 
    Preceding writes for x333 {7,1,0}: 
    Preceding writes for x333 {0,0,0}: 
    Preceding writes for x333 {5,1,0}: 
    Preceding writes for x333 {6,1,0}: 
    Preceding writes for x333 {3,1,0}: 
    Preceding writes for x333 {0,1,0}: 
    Preceding writes for x333 {8,1,0}: 
    Preceding writes for x333 {6,0,0}: 
    Preceding writes for x333 {8,0,0}: 
    Preceding writes for x333 {1,1,0}: 
    Preceding writes for x333 {2,0,0}: 
    x333 <-> x317: LCA: x444 (stage: -1), coarse-dist: <None>
    x317 <-> x317: LCA: x318 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  General read dephasing rules for x268: (b33,List(1, 1, 0)) -> (b33,0)
  - (b20,List(5, 1, 0)) -> (b20,0)
  - (b27,List(5, 1, 0)) -> (b27,0)
  - (b20,List(9, 1, 0)) -> (b20,0)
  - (b33,List(8, 0, 0)) -> (b33,0)
  - (b20,List(2, 1, 0)) -> (b20,0)
  - (b33,List(0, 0, 0)) -> (b33,0)
  - (b20,List(3, 1, 0)) -> (b20,0)
  - (b33,List(7, 0, 0)) -> (b33,0)
  - (b27,List(0, 1, 0)) -> (b27,0)
  - (b27,List(3, 1, 0)) -> (b27,0)
  - (b20,List(4, 1, 0)) -> (b20,0)
  - (b20,List(0, 0, 0)) -> (b20,0)
  - (b33,List(2, 0, 0)) -> (b33,0)
  - (b27,List(0, 0, 0)) -> (b27,0)
  - (b33,List(1, 0, 0)) -> (b33,0)
  - (b33,List(2, 1, 0)) -> (b33,0)
  - (b27,List(7, 0, 0)) -> (b27,0)
  - (b27,List(1, 1, 0)) -> (b27,0)
  - (b27,List(7, 1, 0)) -> (b27,0)
  - (b27,List(2, 1, 0)) -> (b27,0)
  - (b33,List(4, 1, 0)) -> (b33,0)
  - (b20,List(6, 0, 0)) -> (b20,0)
  - (b27,List(9, 0, 0)) -> (b27,0)
  - (b20,List(2, 0, 0)) -> (b20,0)
  - (b33,List(5, 1, 0)) -> (b33,0)
  - (b27,List(9, 1, 0)) -> (b27,0)
  - (b27,List(8, 0, 0)) -> (b27,0)
  - (b20,List(4, 0, 0)) -> (b20,0)
  - (b27,List(6, 1, 0)) -> (b27,0)
  - (b27,List(4, 1, 0)) -> (b27,0)
  - (b33,List(9, 1, 0)) -> (b33,0)
  - (b27,List(8, 1, 0)) -> (b27,0)
  - (b33,List(9, 0, 0)) -> (b33,0)
  - (b27,List(6, 0, 0)) -> (b27,0)
  - (b20,List(9, 0, 0)) -> (b20,0)
  - (b20,List(7, 0, 0)) -> (b20,0)
  - (b20,List(8, 0, 0)) -> (b20,0)
  - (b33,List(3, 0, 0)) -> (b33,0)
  - (b33,List(5, 0, 0)) -> (b33,0)
  - (b27,List(3, 0, 0)) -> (b27,0)
  - (b20,List(5, 0, 0)) -> (b20,0)
  - (b33,List(4, 0, 0)) -> (b33,0)
  - (b33,List(8, 1, 0)) -> (b33,0)
  - (b33,List(6, 1, 0)) -> (b33,0)
  - (b20,List(6, 1, 0)) -> (b20,0)
  - (b27,List(2, 0, 0)) -> (b27,0)
  - (b20,List(8, 1, 0)) -> (b20,0)
  - (b20,List(1, 1, 0)) -> (b20,0)
  - (b33,List(0, 1, 0)) -> (b33,0)
  - (b20,List(1, 0, 0)) -> (b20,0)
  - (b33,List(3, 1, 0)) -> (b33,0)
  - (b20,List(7, 1, 0)) -> (b20,0)
  - (b27,List(1, 0, 0)) -> (b27,0)
  - (b27,List(5, 0, 0)) -> (b27,0)
  - (b33,List(7, 1, 0)) -> (b33,0)
  - (b27,List(4, 0, 0)) -> (b27,0)
  - (b20,List(3, 0, 0)) -> (b20,0)
  - (b33,List(6, 0, 0)) -> (b33,0)
  - (b20,List(0, 1, 0)) -> (b20,0)
  Dephasing Iters: x317 = SRAMWrite(x268,x316,List(b251, x315),Set(x314)) wr{0,0}
 b251  b146  b460     c   mod
    1     0     0     0     0
    0     1    -1     0     0wr -> x318
  Leaf: x318, Iters: ListBuffer(b251, b146), target: x319, elements: ListBuffer(b251, b146)
  Leaf: x318, Iters: ListBuffer(b251, b146), target: x319, elements: List(0, 0)
  Leaf: x318, Iters: ListBuffer(b251, b146), target: x319, elements: List(0, 0)
  General write dephasing rules for x268: (b251,List(0, 0)) -> (b251,0)
  - (b146,List(0, 0)) -> (b146,0)
  Finding scheme for BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Original banking group #0 has (1 accesses)
       b251     c   mod
          1     0     0wr
  Original banking group #1 has (2 accesses)
       b27    c  mod
         2    0    0rd
       b27    c  mod
         2    1    0rd
  Regrouped banking group #0 has (1 accesses)
       b251     c   mod
          1     0     0wr
  Regrouped banking group #1 has (2 accesses)
       b27    c  mod
         2    0    0rd
       b27    c  mod
         2    1    0rd
   Solution space: 3 * 24 * 11 (B), check complexity: 1
       Checking N=2 and alpha=List(0)
       Checking N=2 and alpha=List(1)
       Success on N=2, alpha=List(1), B=1
       Checking N=2 and alpha=List(2)
   Solution space: 4 * 24 * 11 (B), check complexity: 1
       Checking N=3 and alpha=List(0)
       Checking N=3 and alpha=List(1)
       Success on N=3, alpha=List(1), B=1
         x268: Found 2 solutions after 5 (= 5 * 1) attempts to find solution for NBestGuess AlphaBestGuess List(0)
  Original banking group #0 has (1 accesses)
       b146  b460     c   mod
          1    -1     0     0wr
  Original banking group #1 has (1 accesses)
       b33    c  mod
         1    0    0rd
  Regrouped banking group #0 has (1 accesses)
       b146  b460     c   mod
          1    -1     0     0wr
  Regrouped banking group #1 has (1 accesses)
       b33    c  mod
         1    0    0rd
  Cache hit on 2 accesses, NBestGuess, AlphaBestGuess, axes List(1)!  Good job! (scheme Some(Some(List(Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  Banking scheme List(Dims {0}: Cyclic: N=2, B=1, alpha=<1>, P=<2> (72 solutions, 1 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List()) to 1 
  Banking scheme List(Dims {0}: Cyclic: N=3, B=1, alpha=<1>, P=<3> (96 solutions, 1 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List()) to 2 
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(1)))
  Finding scheme for BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Original banking group #0 has (1 accesses)
       b251     c   mod
          1     0     0wr
  Regrouped banking group #0 has (1 accesses)
       b251     c   mod
          1     0     0wr
  Cache hit on 1 accesses, NBestGuess, AlphaBestGuess, axes List(0)!  Good job! (scheme Some(Some(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  Original banking group #0 has (1 accesses)
       b146  b460     c   mod
          1    -1     0     0wr
  Regrouped banking group #0 has (1 accesses)
       b146  b460     c   mod
          1    -1     0     0wr
  Cache hit on 1 accesses, NBestGuess, AlphaBestGuess, axes List(1)!  Good job! (scheme Some(Some(List(Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 1 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 2 
  Finding scheme for BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Original banking group #0 has (1 accesses)
       b251  b146  b460     c   mod
          1     0     0     0     0
          0     1    -1     0     0wr
  Original banking group #1 has (2 accesses)
       b27  b33    c  mod
         2    0    0    0
         0    1    0    0rd
       b27  b33    c  mod
         2    0    1    0
         0    1    0    0rd
  Regrouped banking group #0 has (1 accesses)
       b251  b146  b460     c   mod
          1     0     0     0     0
          0     1    -1     0     0wr
  Regrouped banking group #1 has (2 accesses)
       b27  b33    c  mod
         2    0    0    0
         0    1    0    0rd
       b27  b33    c  mod
         2    0    1    0
         0    1    0    0rd
   Solution space: 6 * 36 * 11 (B), check complexity: 1
       Checking N=2 and alpha=List(0, 0)
       Checking N=2 and alpha=List(0, 1)
       Checking N=2 and alpha=List(1, 0)
       Success on N=2, alpha=List(1, 0), B=1
       Checking N=2 and alpha=List(1, 1)
       Success on N=2, alpha=List(1, 1), B=1
         x268: Found 2 solutions after 4 (= 4 * 1) attempts to find solution for NBestGuess AlphaBestGuess List(0, 1)
  Banking scheme List(Dims {0,1}: Cyclic: N=2, B=1, alpha=<1,0>, P=<2,1> (216 solutions, 1 checks)) accepted!
  incrementing Flat(2), RegroupDims(List()) to 1 
  Banking scheme List(Dims {0,1}: Cyclic: N=2, B=1, alpha=<1,1>, P=<1,2> (216 solutions, 1 checks)) accepted!
  incrementing Flat(2), RegroupDims(List()) to 2 
  Banking scheme List(Dims {0,1}: Cyclic: N=2, B=1, alpha=<1,1>, P=<2,1> (216 solutions, 1 checks)) accepted!
  incrementing Flat(2), RegroupDims(List()) to 3 
  Finding scheme for BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Original banking group #0 has (1 accesses)
       b251  b146  b460     c   mod
          1     0     0     0     0
          0     1    -1     0     0wr
  Regrouped banking group #0 has (1 accesses)
       b251  b146  b460     c   mod
          1     0     0     0     0
          0     1    -1     0     0wr
  Cache hit on 1 accesses, NBestGuess, AlphaBestGuess, axes List(0, 1)!  Good job! (scheme Some(Some(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))))
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 1 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 2 
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List(1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List(1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List(1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NBestGuess,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NBestGuess,AlphaRelaxed,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaBestGuess,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaBestGuess,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaRelaxed,RegroupDims(List(0, 1)))
  solution bankings are Map(BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=2, B=1, alpha=<1>, P=<2> (72 solutions, 1 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)), List(Dims {0}: Cyclic: N=3, B=1, alpha=<1>, P=<3> (96 solutions, 1 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))), BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) -> Map(Set(Set(x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))), BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=2, B=1, alpha=<1,0>, P=<2,1> (216 solutions, 1 checks)), List(Dims {0,1}: Cyclic: N=2, B=1, alpha=<1,1>, P=<1,2> (216 solutions, 1 checks)), List(Dims {0,1}: Cyclic: N=2, B=1, alpha=<1,1>, P=<2,1> (216 solutions, 1 checks)))), BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) -> Map(Set(Set(x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd, x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))))
  x444: AccelScope (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
    x320: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
      x319: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x318: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
          x317: SRAMWrite
    x396: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
        x336: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
          x333: SRAMRead
  **************************************************************************************
  Analyzing costs for banking schemes found for A_sram (x268)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 20 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=2, B=1, alpha=<1>, P=<2> (72 solutions, 1 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 20 | 0 |
            | 2 | 0 | 1 |
          - Duplicate costs 101.39789127992395 (SRAM LUTs: 1.3157894736842106%, FFs: 0.08210180623973727%, BRAMs: 100.0%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 1 instance 0:
    - 20 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=3, B=1, alpha=<1>, P=<3> (96 solutions, 1 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 3 | 20 | 1 |
          - Duplicate costs 542.14072537666 (SRAM LUTs: 7.035087719298246%, FFs: 0.4389709906951286%, BRAMs: 534.6666666666666%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 0:
    - 10 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 10 | 1 |
          - Duplicate costs 82.47028490767147 (SRAM LUTs: 1.0701754385964912%, FFs: 0.06677613574165299%, BRAMs: 81.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 1:
    - 10 readers connect to duplicate #1 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 10 | 1 |
          - Duplicate costs 82.47028490767147 (SRAM LUTs: 1.0701754385964912%, FFs: 0.06677613574165299%, BRAMs: 81.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 20 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=2, B=1, alpha=<1,0>, P=<2,1> (216 solutions, 1 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 20 | 0 |
            | 2 | 0 | 1 |
          - Duplicate costs 101.39789127992395 (SRAM LUTs: 1.3157894736842106%, FFs: 0.08210180623973727%, BRAMs: 100.0%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 1 instance 0:
    - 20 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=2, B=1, alpha=<1,1>, P=<1,2> (216 solutions, 1 checks)))
            Access Hist:
            | width | R | W |
            | 2 | 20 | 1 |
          - Duplicate costs 203.6970971490028 (SRAM LUTs: 2.6432748538011697%, FFs: 0.16493340631271666%, BRAMs: 200.88888888888889%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 2 instance 0:
    - 20 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=2, B=1, alpha=<1,1>, P=<2,1> (216 solutions, 1 checks)))
            Access Hist:
            | width | R | W |
            | 2 | 20 | 1 |
          - Duplicate costs 209.55564197850947 (SRAM LUTs: 2.719298245614035%, FFs: 0.16967706622879036%, BRAMs: 206.66666666666666%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 0:
    - 10 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 10 | 1 |
          - Duplicate costs 82.47028490767147 (SRAM LUTs: 1.0701754385964912%, FFs: 0.06677613574165299%, BRAMs: 81.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 1:
    - 10 readers connect to duplicate #1 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 10 | 1 |
          - Duplicate costs 82.47028490767147 (SRAM LUTs: 1.0701754385964912%, FFs: 0.06677613574165299%, BRAMs: 81.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 101.39789127992395 for version 0 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 542.14072537666 for version 1 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 164.94056981534294 for version 0 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Cost: 101.39789127992395 for version 0 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 203.6970971490028 for version 1 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 209.55564197850947 for version 2 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 164.94056981534294 for version 0 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  **************************************************************************************
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(1, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(2, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(3, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(5, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(6, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(7, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(8, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 0, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
  Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
 b27  b33    c  mod
   2    0    1    0
   0    1    0    0rd -> x336
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(9, 1, 0)
  Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 1, 0)
    Reads:
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    0    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,0,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    0    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,0,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    0    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,1,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    1    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,1,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    1    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,0,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    0    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,0,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    0    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,0,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    0    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{9,1,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    1    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{7,1,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    1    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,0,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    0    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{5,1,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    1    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,1,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    1    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{3,1,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    1    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{0,1,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    1    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,1,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    1    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{6,0,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    0    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{8,0,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    0    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{1,1,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    1    0
      grp 0:    0    1    0    0rd
      grp 0: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{2,0,0}
      grp 0:  b27  b33    c  mod
      grp 0:    2    0    0    0
      grp 0:    0    1    0    0rd
    Writes:
      grp 0: x317 = SRAMWrite(x268,x316,List(b251, x315),Set(x314)) wr{0,0}
      grp 0:  b251  b146  b460     c   mod
      grp 0:     1     0     0     0     0
      grp 0:     0     1    -1     0     0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List(0, 0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=2, B=1, alpha=<1>, P=<2> (72 solutions, 1 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Hierarchical>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x317 = SRAMWrite(x268,x316,List(b251, x315),Set(x314)) {0,0}
      - ProjectTemplate.scala:21:14: A_sram load A_dram
      - Scope: x318 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {0,0,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {0,1,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {1,0,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {1,1,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {2,0,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {2,1,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {3,0,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {3,1,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {4,0,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {4,1,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {5,0,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {5,1,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {6,0,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {6,1,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {7,0,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {7,1,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {8,0,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {8,1,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {9,0,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)
  [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {9,1,0}
      - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
      - Scope: x336 (scope: 0, 0)))
  Attempting to merge group #1 with instance #0: 
    Computing overlaps: x333 = Some(SRAMRead(x268,List(b27, b33),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
    Dephasing Iters: x333 = SRAMRead(x268,List(b27, b33),Set()) rd{4,0,0}
 b27  b33    c  mod
   2    0    0    0
   0    1    0    0rd -> x336
    Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: ListBuffer(b20, b27, b33)
    Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(4, 0, 0)
    Leaf: x336, Iters: ListBuffer(b20, b27, b33), target: x396, elements: List(0, 1, 0)
    x333 {4,0,0}, x332 {0,1,0}: Concurrent: true, Conflicting: true
    Did not merge 1 into instance 0: Control conflict: Common control (x336 (stage: -1))
  Result: Created instance #1
Group #2: 
    Preceding writes for x392 {4,0}: 
      x317 {0,0}
    Preceding writes for x392 {6,0}: 
    Preceding writes for x392 {0,0}: 
    Preceding writes for x392 {8,0}: 
    Preceding writes for x392 {7,0}: 
    Preceding writes for x392 {3,0}: 
    Preceding writes for x392 {5,0}: 
    Preceding writes for x392 {1,0}: 
    Preceding writes for x392 {9,0}: 
    Preceding writes for x392 {2,0}: 
    x392 <-> x317: LCA: x444 (stage: -1), coarse-dist: <None>
    x317 <-> x317: LCA: x318 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0rd -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(4, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0rd -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(6, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{0,0}
 b20  b81    c  mod
  10    0    0    0
   0    1    0    0rd -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0rd -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(8, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0rd -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(7, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{3,0}
 b20  b81    c  mod
  10    0    3    0
   0    1    0    0rd -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(3, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0rd -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(5, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{1,0}
 b20  b81    c  mod
  10    0    1    0
   0    1    0    0rd -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(1, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(9, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  Dephasing Iters: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{2,0}
 b20  b81    c  mod
  10    0    2    0
   0    1    0    0rd -> x395
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: ListBuffer(b20, b81)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(2, 0)
  Leaf: x395, Iters: ListBuffer(b20, b81), target: x396, elements: List(0, 0)
  General read dephasing rules for x268: (b81,List(7, 0)) -> (b81,0)
  - (b81,List(2, 0)) -> (b81,0)
  - (b20,List(6, 0)) -> (b20,0)
  - (b81,List(0, 0)) -> (b81,0)
  - (b20,List(3, 0)) -> (b20,0)
  - (b20,List(4, 0)) -> (b20,0)
  - (b20,List(7, 0)) -> (b20,0)
  - (b81,List(6, 0)) -> (b81,0)
  - (b20,List(0, 0)) -> (b20,0)
  - (b81,List(4, 0)) -> (b81,0)
  - (b20,List(2, 0)) -> (b20,0)
  - (b81,List(1, 0)) -> (b81,0)
  - (b81,List(3, 0)) -> (b81,0)
  - (b81,List(5, 0)) -> (b81,0)
  - (b20,List(1, 0)) -> (b20,0)
  - (b20,List(8, 0)) -> (b20,0)
  - (b81,List(8, 0)) -> (b81,0)
  - (b20,List(9, 0)) -> (b20,0)
  - (b20,List(5, 0)) -> (b20,0)
  - (b81,List(9, 0)) -> (b81,0)
  Dephasing Iters: x317 = SRAMWrite(x268,x316,List(b251, x315),Set(x314)) wr{0,0}
 b251  b146  b460     c   mod
    1     0     0     0     0
    0     1    -1     0     0wr -> x318
  Leaf: x318, Iters: ListBuffer(b251, b146), target: x319, elements: ListBuffer(b251, b146)
  Leaf: x318, Iters: ListBuffer(b251, b146), target: x319, elements: List(0, 0)
  Leaf: x318, Iters: ListBuffer(b251, b146), target: x319, elements: List(0, 0)
  General write dephasing rules for x268: (b251,List(0, 0)) -> (b251,0)
  - (b146,List(0, 0)) -> (b146,0)
  Finding scheme for BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Original banking group #0 has (1 accesses)
       b251     c   mod
          1     0     0wr
  Original banking group #1 has (10 accesses)
       b20    c  mod
        10    4    0rd
       b20    c  mod
        10    7    0rd
       b20    c  mod
        10    9    0rd
       b20    c  mod
        10    8    0rd
       b20    c  mod
        10    1    0rd
       b20    c  mod
        10    3    0rd
       b20    c  mod
        10    6    0rd
       b20    c  mod
        10    0    0rd
       b20    c  mod
        10    5    0rd
       b20    c  mod
        10    2    0rd
  Regrouped banking group #0 has (1 accesses)
       b251     c   mod
          1     0     0wr
  Regrouped banking group #1 has (10 accesses)
       b20    c  mod
        10    4    0rd
       b20    c  mod
        10    7    0rd
       b20    c  mod
        10    9    0rd
       b20    c  mod
        10    8    0rd
       b20    c  mod
        10    1    0rd
       b20    c  mod
        10    3    0rd
       b20    c  mod
        10    6    0rd
       b20    c  mod
        10    0    0rd
       b20    c  mod
        10    5    0rd
       b20    c  mod
        10    2    0rd
  Cache hit on 11 accesses, NBestGuess, AlphaBestGuess, axes List(0)!  Good job! (scheme Some(Some(List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {0}: Cyclic: N=10, B=1, alpha=<3>, P=<10> (176 solutions, 46 checks)))))
  Original banking group #0 has (1 accesses)
       b146  b460     c   mod
          1    -1     0     0wr
  Original banking group #1 has (1 accesses)
       b81    c  mod
         1    0    0rd
  Regrouped banking group #0 has (1 accesses)
       b146  b460     c   mod
          1    -1     0     0wr
  Regrouped banking group #1 has (1 accesses)
       b81    c  mod
         1    0    0rd
  Banking scheme List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List()) to 1 
  Banking scheme List(Dims {0}: Cyclic: N=10, B=1, alpha=<3>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List()) to 2 
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(1)))
  Finding scheme for BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Original banking group #0 has (1 accesses)
       b251     c   mod
          1     0     0wr
  Regrouped banking group #0 has (1 accesses)
       b251     c   mod
          1     0     0wr
  Cache hit on 1 accesses, NBestGuess, AlphaBestGuess, axes List(0)!  Good job! (scheme Some(Some(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  Original banking group #0 has (1 accesses)
       b146  b460     c   mod
          1    -1     0     0wr
  Regrouped banking group #0 has (1 accesses)
       b146  b460     c   mod
          1    -1     0     0wr
  Cache hit on 1 accesses, NBestGuess, AlphaBestGuess, axes List(1)!  Good job! (scheme Some(Some(List(Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 1 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 2 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 3 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 4 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 5 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 6 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 7 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 8 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 9 
  Banking scheme List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) accepted!
  incrementing Hierarchical(2,None), RegroupDims(List(0, 1)) to 10 
  Finding scheme for BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Original banking group #0 has (1 accesses)
       b251  b146  b460     c   mod
          1     0     0     0     0
          0     1    -1     0     0wr
  Original banking group #1 has (10 accesses)
       b20  b81    c  mod
        10    0    4    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    1    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    5    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    0    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    8    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    2    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    9    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    7    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    3    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    6    0
         0    1    0    0rd
  Regrouped banking group #0 has (1 accesses)
       b251  b146  b460     c   mod
          1     0     0     0     0
          0     1    -1     0     0wr
  Regrouped banking group #1 has (10 accesses)
       b20  b81    c  mod
        10    0    4    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    1    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    5    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    0    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    8    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    2    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    9    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    7    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    3    0
         0    1    0    0rd
       b20  b81    c  mod
        10    0    6    0
         0    1    0    0rd
   Solution space: 66 * 28 * 11 (B), check complexity: 46
       Checking N=10 and alpha=List(0, 0)
       Checking N=10 and alpha=List(0, 1)
       Checking N=10 and alpha=List(1, 0)
       Success on N=10, alpha=List(1, 0), B=1
       Checking N=10 and alpha=List(1, 1)
       Success on N=10, alpha=List(1, 1), B=1
         x268: Found 2 solutions after 184 (= 4 * 46) attempts to find solution for NBestGuess AlphaBestGuess List(0, 1)
  Banking scheme List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,0>, P=<10,1> (1848 solutions, 46 checks)) accepted!
  incrementing Flat(2), RegroupDims(List()) to 1 
  Banking scheme List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<1,10> (1848 solutions, 46 checks)) accepted!
  incrementing Flat(2), RegroupDims(List()) to 2 
  Banking scheme List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<10,1> (1848 solutions, 46 checks)) accepted!
  incrementing Flat(2), RegroupDims(List()) to 3 
  Finding scheme for BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Original banking group #0 has (1 accesses)
       b251  b146  b460     c   mod
          1     0     0     0     0
          0     1    -1     0     0wr
  Regrouped banking group #0 has (1 accesses)
       b251  b146  b460     c   mod
          1     0     0     0     0
          0     1    -1     0     0wr
  Cache hit on 1 accesses, NBestGuess, AlphaBestGuess, axes List(0, 1)!  Good job! (scheme Some(Some(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))))
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 1 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 2 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 3 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 4 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 5 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 6 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 7 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 8 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 9 
  Banking scheme List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) accepted!
  incrementing Flat(2), RegroupDims(List(0, 1)) to 10 
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List(1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaRelaxed,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List(1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaBestGuess,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List(0)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List(1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Hierarchical(2,None),NRelaxed,AlphaRelaxed,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NBestGuess,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NBestGuess,AlphaRelaxed,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaBestGuess,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaBestGuess,RegroupDims(List(0, 1)))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  Because 1 effort level, skipping search for scheme BankingOptions(Flat(2),NRelaxed,AlphaRelaxed,RegroupDims(List(0, 1)))
  solution bankings are Map(BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{0,0}
 b20  b81    c  mod
  10    0    0    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{3,0}
 b20  b81    c  mod
  10    0    3    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{1,0}
 b20  b81    c  mod
  10    0    1    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{2,0}
 b20  b81    c  mod
  10    0    2    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)), List(Dims {0}: Cyclic: N=10, B=1, alpha=<3>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))), BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) -> Map(Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{0,0}
 b20  b81    c  mod
  10    0    0    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{1,0}
 b20  b81    c  mod
  10    0    1    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{2,0}
 b20  b81    c  mod
  10    0    2    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{3,0}
 b20  b81    c  mod
  10    0    3    0
   0    1    0    0rd)) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))), BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{0,0}
 b20  b81    c  mod
  10    0    0    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{3,0}
 b20  b81    c  mod
  10    0    3    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{1,0}
 b20  b81    c  mod
  10    0    1    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd, x392 = SRAMRead(x268,List(b20, b81),Set()) rd{2,0}
 b20  b81    c  mod
  10    0    2    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,0>, P=<10,1> (1848 solutions, 46 checks)), List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<1,10> (1848 solutions, 46 checks)), List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<10,1> (1848 solutions, 46 checks)))), BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) -> Map(Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{0,0}
 b20  b81    c  mod
  10    0    0    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{1,0}
 b20  b81    c  mod
  10    0    1    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{6,0}
 b20  b81    c  mod
  10    0    6    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{4,0}
 b20  b81    c  mod
  10    0    4    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
 b20  b81    c  mod
  10    0    7    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
 b20  b81    c  mod
  10    0    8    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{5,0}
 b20  b81    c  mod
  10    0    5    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
 b20  b81    c  mod
  10    0    9    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{2,0}
 b20  b81    c  mod
  10    0    2    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks))), Set(Set(x392 = SRAMRead(x268,List(b20, b81),Set()) rd{3,0}
 b20  b81    c  mod
  10    0    3    0
   0    1    0    0rd)) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))))
  x444: AccelScope (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
    x320: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
      x319: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x318: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
          x317: SRAMWrite
    x396: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x395: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
        x392: SRAMRead
  **************************************************************************************
  Analyzing costs for banking schemes found for A_sram (x268)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 10 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 10 | 0 |
            | 10 | 0 | 1 |
          - Duplicate costs 271.74634863019617 (SRAM LUTs: 3.526315789473684%, FFs: 0.2200328407224959%, BRAMs: 268.0%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 1 instance 0:
    - 10 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=10, B=1, alpha=<3>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 10 | 0 |
            | 10 | 0 | 1 |
          - Duplicate costs 273.09832051392846 (SRAM LUTs: 3.543859649122807%, FFs: 0.22112753147235906%, BRAMs: 269.3333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 1:
    - 1 readers connect to duplicate #1 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 2:
    - 1 readers connect to duplicate #2 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 3:
    - 1 readers connect to duplicate #3 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 4:
    - 1 readers connect to duplicate #4 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 5:
    - 1 readers connect to duplicate #5 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 6:
    - 1 readers connect to duplicate #6 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 7:
    - 1 readers connect to duplicate #7 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 8:
    - 1 readers connect to duplicate #8 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 9:
    - 1 readers connect to duplicate #9 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 10 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,0>, P=<10,1> (1848 solutions, 46 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 10 | 0 |
            | 10 | 0 | 1 |
          - Duplicate costs 271.74634863019617 (SRAM LUTs: 3.526315789473684%, FFs: 0.2200328407224959%, BRAMs: 268.0%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 1 instance 0:
    - 10 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<1,10> (1848 solutions, 46 checks)))
            Access Hist:
            | width | R | W |
            | 10 | 10 | 1 |
          - Duplicate costs 1811.642324201308 (SRAM LUTs: 23.50877192982456%, FFs: 1.4668856048166392%, BRAMs: 1786.6666666666667%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 2 instance 0:
    - 10 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=10, B=1, alpha=<1,1>, P=<10,1> (1848 solutions, 46 checks)))
            Access Hist:
            | width | R | W |
            | 10 | 10 | 1 |
          - Duplicate costs 1668.7839618202595 (SRAM LUTs: 21.65497076023392%, FFs: 1.351213282247765%, BRAMs: 1645.7777777777778%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 1:
    - 1 readers connect to duplicate #1 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 2:
    - 1 readers connect to duplicate #2 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 3:
    - 1 readers connect to duplicate #3 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 4:
    - 1 readers connect to duplicate #4 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 5:
    - 1 readers connect to duplicate #5 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 6:
    - 1 readers connect to duplicate #6 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 7:
    - 1 readers connect to duplicate #7 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 8:
    - 1 readers connect to duplicate #8 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  Scheme BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1))) option 0 instance 9:
    - 1 readers connect to duplicate #9 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 70.3025379540806 (SRAM LUTs: 0.9122807017543859%, FFs: 0.05692391899288451%, BRAMs: 69.33333333333333%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 271.74634863019617 for version 0 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 273.09832051392846 for version 1 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 703.0253795408062 for version 0 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  Cost: 271.74634863019617 for version 0 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 1811.642324201308 for version 1 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 1668.7839618202595 for version 2 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  Cost: 703.0253795408062 for version 0 of BankingOptions(Flat(2),NBestGuess,AlphaBestGuess,RegroupDims(List(0, 1)))
  **************************************************************************************
    Reads:
      grp 0: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{4,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    4    0
      grp 0:    0    1    0    0rd
      grp 0: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{6,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    6    0
      grp 0:    0    1    0    0rd
      grp 0: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{0,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    0    0
      grp 0:    0    1    0    0rd
      grp 0: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{8,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    8    0
      grp 0:    0    1    0    0rd
      grp 0: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{7,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    7    0
      grp 0:    0    1    0    0rd
      grp 0: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{3,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    3    0
      grp 0:    0    1    0    0rd
      grp 0: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{5,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    5    0
      grp 0:    0    1    0    0rd
      grp 0: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{1,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    1    0
      grp 0:    0    1    0    0rd
      grp 0: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{9,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    9    0
      grp 0:    0    1    0    0rd
      grp 0: x392 = SRAMRead(x268,List(b20, b81),Set()) rd{2,0}
      grp 0:  b20  b81    c  mod
      grp 0:   10    0    2    0
      grp 0:    0    1    0    0rd
    Writes:
      grp 0: x317 = SRAMWrite(x268,x316,List(b251, x315),Set(x314)) wr{0,0}
      grp 0:  b251  b146  b460     c   mod
      grp 0:     1     0     0     0     0
      grp 0:     0     1    -1     0     0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List(0, 0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Hierarchical>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x317 = SRAMWrite(x268,x316,List(b251, x315),Set(x314)) {0,0}
      - ProjectTemplate.scala:21:14: A_sram load A_dram
      - Scope: x318 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x392 = SRAMRead(x268,List(b20, b81),Set()) {0,0}
      - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 1] x392 = SRAMRead(x268,List(b20, b81),Set()) {1,0}
      - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 2] x392 = SRAMRead(x268,List(b20, b81),Set()) {2,0}
      - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 3] x392 = SRAMRead(x268,List(b20, b81),Set()) {3,0}
      - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 4] x392 = SRAMRead(x268,List(b20, b81),Set()) {4,0}
      - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 5] x392 = SRAMRead(x268,List(b20, b81),Set()) {5,0}
      - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 6] x392 = SRAMRead(x268,List(b20, b81),Set()) {6,0}
      - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 7] x392 = SRAMRead(x268,List(b20, b81),Set()) {7,0}
      - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 8] x392 = SRAMRead(x268,List(b20, b81),Set()) {8,0}
      - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)
  [Ofs: 9] x392 = SRAMRead(x268,List(b20, b81),Set()) {9,0}
      - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
      - Scope: x395 (scope: 0, 0)))
  Attempting to merge group #2 with instance #0: 
    Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
    Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x332 = Some(SRAMRead(x268,List(b20, b33),Set()))
    x392 {4,0}, x332 {4,1,0}: Concurrent: true, Conflicting: true
    Did not merge 2 into instance 0: Instances conflict: x392 {4,0} / x332 {4,1,0}
  Attempting to merge group #2 with instance #1: 
    Computing overlaps: x392 = Some(SRAMRead(x268,List(b20, b81),Set())) - x333 = Some(SRAMRead(x268,List(b27, b33),Set()))
    x392 {4,0}, x333 {4,0,0}: Concurrent: true, Conflicting: true
    Did not merge 2 into instance 1: Instances conflict: x392 {4,0} / x333 {4,0,0}
  Result: Created instance #2
---------------------------------------------------------------------
SUMMARY: 
Name: A_sram (x268)
Type: SRAM2[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:19:27
Src:        val A_sram = SRAM[T](N, 3)
Symbol:     x268 = SRAMNew(List(Const(100), Const(3)),SRAM2[Fix[TRUE,_10,_22]])
---------------------------------------------------------------------
Instances: 3
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0, 0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Hierarchical>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x317 = SRAMWrite(x268,x316,List(b251, x315),Set(x314)) {0,0}
        - ProjectTemplate.scala:21:14: A_sram load A_dram
        - Scope: x318 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x332 = SRAMRead(x268,List(b20, b33),Set()) {0,0,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 0] x332 = SRAMRead(x268,List(b20, b33),Set()) {0,1,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 1] x332 = SRAMRead(x268,List(b20, b33),Set()) {1,0,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 1] x332 = SRAMRead(x268,List(b20, b33),Set()) {1,1,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 2] x332 = SRAMRead(x268,List(b20, b33),Set()) {2,0,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 2] x332 = SRAMRead(x268,List(b20, b33),Set()) {2,1,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 3] x332 = SRAMRead(x268,List(b20, b33),Set()) {3,0,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 3] x332 = SRAMRead(x268,List(b20, b33),Set()) {3,1,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 4] x332 = SRAMRead(x268,List(b20, b33),Set()) {4,0,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 4] x332 = SRAMRead(x268,List(b20, b33),Set()) {4,1,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 5] x332 = SRAMRead(x268,List(b20, b33),Set()) {5,0,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 5] x332 = SRAMRead(x268,List(b20, b33),Set()) {5,1,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 6] x332 = SRAMRead(x268,List(b20, b33),Set()) {6,0,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 6] x332 = SRAMRead(x268,List(b20, b33),Set()) {6,1,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 7] x332 = SRAMRead(x268,List(b20, b33),Set()) {7,0,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 7] x332 = SRAMRead(x268,List(b20, b33),Set()) {7,1,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 8] x332 = SRAMRead(x268,List(b20, b33),Set()) {8,0,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 8] x332 = SRAMRead(x268,List(b20, b33),Set()) {8,1,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 9] x332 = SRAMRead(x268,List(b20, b33),Set()) {9,0,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 9] x332 = SRAMRead(x268,List(b20, b33),Set()) {9,1,0}
        - ProjectTemplate.scala:35:51: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)



Instance #1
  <Banked>
  Depth:    1
  Padding:  List(0, 0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=2, B=1, alpha=<1>, P=<2> (72 solutions, 1 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Hierarchical>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x317 = SRAMWrite(x268,x316,List(b251, x315),Set(x314)) {0,0}
        - ProjectTemplate.scala:21:14: A_sram load A_dram
        - Scope: x318 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {0,0,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {0,1,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {1,0,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {1,1,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {2,0,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {2,1,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {3,0,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {3,1,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {4,0,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {4,1,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {5,0,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {5,1,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {6,0,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {6,1,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {7,0,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {7,1,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {8,0,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {8,1,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 0] x333 = SRAMRead(x268,List(b27, b33),Set()) {9,0,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)
    [Ofs: 1] x333 = SRAMRead(x268,List(b27, b33),Set()) {9,1,0}
        - ProjectTemplate.scala:35:65: Foreach(0 until 3){k=> tmp(k) = A_sram(i,k) - A_sram(j,k)}
        - Scope: x336 (scope: 0, 0)



Instance #2
  <Banked>
  Depth:    1
  Padding:  List(0, 0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=10, B=1, alpha=<1>, P=<10> (176 solutions, 46 checks), Dims {1}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Hierarchical>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x317 = SRAMWrite(x268,x316,List(b251, x315),Set(x314)) {0,0}
        - ProjectTemplate.scala:21:14: A_sram load A_dram
        - Scope: x318 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x392 = SRAMRead(x268,List(b20, b81),Set()) {0,0}
        - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 1] x392 = SRAMRead(x268,List(b20, b81),Set()) {1,0}
        - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 2] x392 = SRAMRead(x268,List(b20, b81),Set()) {2,0}
        - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 3] x392 = SRAMRead(x268,List(b20, b81),Set()) {3,0}
        - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 4] x392 = SRAMRead(x268,List(b20, b81),Set()) {4,0}
        - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 5] x392 = SRAMRead(x268,List(b20, b81),Set()) {5,0}
        - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 6] x392 = SRAMRead(x268,List(b20, b81),Set()) {6,0}
        - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 7] x392 = SRAMRead(x268,List(b20, b81),Set()) {7,0}
        - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 8] x392 = SRAMRead(x268,List(b20, b81),Set()) {8,0}
        - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)
    [Ofs: 9] x392 = SRAMRead(x268,List(b20, b81),Set()) {9,0}
        - ProjectTemplate.scala:51:47: out_sram(i, k) = accum(k) + A_sram(i,k)
        - Scope: x395 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(1)) to x332 {0,1,0}
  Added dispatch 0 to x332 {0,1,0}
  Added port Port(Some(0),0,4,List(4),List(1)) to x332 {4,1,0}
  Added dispatch 0 to x332 {4,1,0}
  Added port Port(Some(0),0,7,List(7),List(1)) to x332 {7,1,0}
  Added dispatch 0 to x332 {7,1,0}
  Added port Port(Some(0),0,3,List(3),List(1)) to x332 {3,1,0}
  Added dispatch 0 to x332 {3,1,0}
  Added port Port(Some(0),0,2,List(2),List(1)) to x332 {2,1,0}
  Added dispatch 0 to x332 {2,1,0}
  Added port Port(Some(0),0,1,List(1),List(0)) to x332 {1,0,0}
  Added dispatch 0 to x332 {1,0,0}
  Added port Port(Some(0),0,8,List(8),List(0)) to x332 {8,0,0}
  Added dispatch 0 to x332 {8,0,0}
  Added port Port(Some(0),0,6,List(6),List(0)) to x332 {6,0,0}
  Added dispatch 0 to x332 {6,0,0}
  Added port Port(Some(0),0,9,List(9),List(0)) to x332 {9,0,0}
  Added dispatch 0 to x332 {9,0,0}
  Added port Port(Some(0),0,9,List(9),List(1)) to x332 {9,1,0}
  Added dispatch 0 to x332 {9,1,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x332 {0,0,0}
  Added dispatch 0 to x332 {0,0,0}
  Added port Port(Some(0),0,2,List(2),List(0)) to x332 {2,0,0}
  Added dispatch 0 to x332 {2,0,0}
  Added port Port(Some(0),0,3,List(3),List(0)) to x332 {3,0,0}
  Added dispatch 0 to x332 {3,0,0}
  Added port Port(Some(0),0,8,List(8),List(1)) to x332 {8,1,0}
  Added dispatch 0 to x332 {8,1,0}
  Added port Port(Some(0),0,1,List(1),List(1)) to x332 {1,1,0}
  Added dispatch 0 to x332 {1,1,0}
  Added port Port(Some(0),0,4,List(4),List(0)) to x332 {4,0,0}
  Added dispatch 0 to x332 {4,0,0}
  Added port Port(Some(0),0,6,List(6),List(1)) to x332 {6,1,0}
  Added dispatch 0 to x332 {6,1,0}
  Added port Port(Some(0),0,5,List(5),List(0)) to x332 {5,0,0}
  Added dispatch 0 to x332 {5,0,0}
  Added port Port(Some(0),0,7,List(7),List(0)) to x332 {7,0,0}
  Added dispatch 0 to x332 {7,0,0}
  Added port Port(Some(0),0,5,List(5),List(1)) to x332 {5,1,0}
  Added dispatch 0 to x332 {5,1,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x317 {0,0}
  Added dispatch 0 to x317 {0,0}
  Added port Port(Some(0),0,0,List(0),List(1)) to x332 {0,1,0}
  Added dispatch 0 to x332 {0,1,0}
  Added port Port(Some(0),0,4,List(4),List(1)) to x332 {4,1,0}
  Added dispatch 0 to x332 {4,1,0}
  Added port Port(Some(0),0,7,List(7),List(1)) to x332 {7,1,0}
  Added dispatch 0 to x332 {7,1,0}
  Added port Port(Some(0),0,3,List(3),List(1)) to x332 {3,1,0}
  Added dispatch 0 to x332 {3,1,0}
  Added port Port(Some(0),0,2,List(2),List(1)) to x332 {2,1,0}
  Added dispatch 0 to x332 {2,1,0}
  Added port Port(Some(0),0,1,List(1),List(0)) to x332 {1,0,0}
  Added dispatch 0 to x332 {1,0,0}
  Added port Port(Some(0),0,8,List(8),List(0)) to x332 {8,0,0}
  Added dispatch 0 to x332 {8,0,0}
  Added port Port(Some(0),0,6,List(6),List(0)) to x332 {6,0,0}
  Added dispatch 0 to x332 {6,0,0}
  Added port Port(Some(0),0,9,List(9),List(0)) to x332 {9,0,0}
  Added dispatch 0 to x332 {9,0,0}
  Added port Port(Some(0),0,9,List(9),List(1)) to x332 {9,1,0}
  Added dispatch 0 to x332 {9,1,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x332 {0,0,0}
  Added dispatch 0 to x332 {0,0,0}
  Added port Port(Some(0),0,2,List(2),List(0)) to x332 {2,0,0}
  Added dispatch 0 to x332 {2,0,0}
  Added port Port(Some(0),0,3,List(3),List(0)) to x332 {3,0,0}
  Added dispatch 0 to x332 {3,0,0}
  Added port Port(Some(0),0,8,List(8),List(1)) to x332 {8,1,0}
  Added dispatch 0 to x332 {8,1,0}
  Added port Port(Some(0),0,1,List(1),List(1)) to x332 {1,1,0}
  Added dispatch 0 to x332 {1,1,0}
  Added port Port(Some(0),0,4,List(4),List(0)) to x332 {4,0,0}
  Added dispatch 0 to x332 {4,0,0}
  Added port Port(Some(0),0,6,List(6),List(1)) to x332 {6,1,0}
  Added dispatch 0 to x332 {6,1,0}
  Added port Port(Some(0),0,5,List(5),List(0)) to x332 {5,0,0}
  Added dispatch 0 to x332 {5,0,0}
  Added port Port(Some(0),0,7,List(7),List(0)) to x332 {7,0,0}
  Added dispatch 0 to x332 {7,0,0}
  Added port Port(Some(0),0,5,List(5),List(1)) to x332 {5,1,0}
  Added dispatch 0 to x332 {5,1,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x317 {0,0}
  Added dispatch 0 to x317 {0,0}
  Added port Port(Some(0),0,0,List(0),List(4)) to x333 {4,0,0}
  Added dispatch 1 to x333 {4,0,0}
  Added port Port(Some(0),0,0,List(0),List(5)) to x333 {5,0,0}
  Added dispatch 1 to x333 {5,0,0}
  Added port Port(Some(0),0,0,List(0),List(9)) to x333 {9,0,0}
  Added dispatch 1 to x333 {9,0,0}
  Added port Port(Some(0),0,1,List(1),List(4)) to x333 {4,1,0}
  Added dispatch 1 to x333 {4,1,0}
  Added port Port(Some(0),0,1,List(1),List(2)) to x333 {2,1,0}
  Added dispatch 1 to x333 {2,1,0}
  Added port Port(Some(0),0,0,List(0),List(3)) to x333 {3,0,0}
  Added dispatch 1 to x333 {3,0,0}
  Added port Port(Some(0),0,0,List(0),List(7)) to x333 {7,0,0}
  Added dispatch 1 to x333 {7,0,0}
  Added port Port(Some(0),0,0,List(0),List(1)) to x333 {1,0,0}
  Added dispatch 1 to x333 {1,0,0}
  Added port Port(Some(0),0,1,List(1),List(9)) to x333 {9,1,0}
  Added dispatch 1 to x333 {9,1,0}
  Added port Port(Some(0),0,1,List(1),List(7)) to x333 {7,1,0}
  Added dispatch 1 to x333 {7,1,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x333 {0,0,0}
  Added dispatch 1 to x333 {0,0,0}
  Added port Port(Some(0),0,1,List(1),List(5)) to x333 {5,1,0}
  Added dispatch 1 to x333 {5,1,0}
  Added port Port(Some(0),0,1,List(1),List(6)) to x333 {6,1,0}
  Added dispatch 1 to x333 {6,1,0}
  Added port Port(Some(0),0,1,List(1),List(3)) to x333 {3,1,0}
  Added dispatch 1 to x333 {3,1,0}
  Added port Port(Some(0),0,1,List(1),List(0)) to x333 {0,1,0}
  Added dispatch 1 to x333 {0,1,0}
  Added port Port(Some(0),0,1,List(1),List(8)) to x333 {8,1,0}
  Added dispatch 1 to x333 {8,1,0}
  Added port Port(Some(0),0,0,List(0),List(6)) to x333 {6,0,0}
  Added dispatch 1 to x333 {6,0,0}
  Added port Port(Some(0),0,0,List(0),List(8)) to x333 {8,0,0}
  Added dispatch 1 to x333 {8,0,0}
  Added port Port(Some(0),0,1,List(1),List(1)) to x333 {1,1,0}
  Added dispatch 1 to x333 {1,1,0}
  Added port Port(Some(0),0,0,List(0),List(2)) to x333 {2,0,0}
  Added dispatch 1 to x333 {2,0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x317 {0,0}
  Added dispatch 1 to x317 {0,0}
  Added port Port(Some(0),0,0,List(0),List(4)) to x333 {4,0,0}
  Added dispatch 1 to x333 {4,0,0}
  Added port Port(Some(0),0,0,List(0),List(5)) to x333 {5,0,0}
  Added dispatch 1 to x333 {5,0,0}
  Added port Port(Some(0),0,0,List(0),List(9)) to x333 {9,0,0}
  Added dispatch 1 to x333 {9,0,0}
  Added port Port(Some(0),0,1,List(1),List(4)) to x333 {4,1,0}
  Added dispatch 1 to x333 {4,1,0}
  Added port Port(Some(0),0,1,List(1),List(2)) to x333 {2,1,0}
  Added dispatch 1 to x333 {2,1,0}
  Added port Port(Some(0),0,0,List(0),List(3)) to x333 {3,0,0}
  Added dispatch 1 to x333 {3,0,0}
  Added port Port(Some(0),0,0,List(0),List(7)) to x333 {7,0,0}
  Added dispatch 1 to x333 {7,0,0}
  Added port Port(Some(0),0,0,List(0),List(1)) to x333 {1,0,0}
  Added dispatch 1 to x333 {1,0,0}
  Added port Port(Some(0),0,1,List(1),List(9)) to x333 {9,1,0}
  Added dispatch 1 to x333 {9,1,0}
  Added port Port(Some(0),0,1,List(1),List(7)) to x333 {7,1,0}
  Added dispatch 1 to x333 {7,1,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x333 {0,0,0}
  Added dispatch 1 to x333 {0,0,0}
  Added port Port(Some(0),0,1,List(1),List(5)) to x333 {5,1,0}
  Added dispatch 1 to x333 {5,1,0}
  Added port Port(Some(0),0,1,List(1),List(6)) to x333 {6,1,0}
  Added dispatch 1 to x333 {6,1,0}
  Added port Port(Some(0),0,1,List(1),List(3)) to x333 {3,1,0}
  Added dispatch 1 to x333 {3,1,0}
  Added port Port(Some(0),0,1,List(1),List(0)) to x333 {0,1,0}
  Added dispatch 1 to x333 {0,1,0}
  Added port Port(Some(0),0,1,List(1),List(8)) to x333 {8,1,0}
  Added dispatch 1 to x333 {8,1,0}
  Added port Port(Some(0),0,0,List(0),List(6)) to x333 {6,0,0}
  Added dispatch 1 to x333 {6,0,0}
  Added port Port(Some(0),0,0,List(0),List(8)) to x333 {8,0,0}
  Added dispatch 1 to x333 {8,0,0}
  Added port Port(Some(0),0,1,List(1),List(1)) to x333 {1,1,0}
  Added dispatch 1 to x333 {1,1,0}
  Added port Port(Some(0),0,0,List(0),List(2)) to x333 {2,0,0}
  Added dispatch 1 to x333 {2,0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x317 {0,0}
  Added dispatch 1 to x317 {0,0}
  Added port Port(Some(0),0,4,List(4),List(0)) to x392 {4,0}
  Added dispatch 2 to x392 {4,0}
  Added port Port(Some(0),0,6,List(6),List(0)) to x392 {6,0}
  Added dispatch 2 to x392 {6,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x392 {0,0}
  Added dispatch 2 to x392 {0,0}
  Added port Port(Some(0),0,8,List(8),List(0)) to x392 {8,0}
  Added dispatch 2 to x392 {8,0}
  Added port Port(Some(0),0,7,List(7),List(0)) to x392 {7,0}
  Added dispatch 2 to x392 {7,0}
  Added port Port(Some(0),0,3,List(3),List(0)) to x392 {3,0}
  Added dispatch 2 to x392 {3,0}
  Added port Port(Some(0),0,5,List(5),List(0)) to x392 {5,0}
  Added dispatch 2 to x392 {5,0}
  Added port Port(Some(0),0,1,List(1),List(0)) to x392 {1,0}
  Added dispatch 2 to x392 {1,0}
  Added port Port(Some(0),0,9,List(9),List(0)) to x392 {9,0}
  Added dispatch 2 to x392 {9,0}
  Added port Port(Some(0),0,2,List(2),List(0)) to x392 {2,0}
  Added dispatch 2 to x392 {2,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x317 {0,0}
  Added dispatch 2 to x317 {0,0}
  Added port Port(Some(0),0,4,List(4),List(0)) to x392 {4,0}
  Added dispatch 2 to x392 {4,0}
  Added port Port(Some(0),0,6,List(6),List(0)) to x392 {6,0}
  Added dispatch 2 to x392 {6,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x392 {0,0}
  Added dispatch 2 to x392 {0,0}
  Added port Port(Some(0),0,8,List(8),List(0)) to x392 {8,0}
  Added dispatch 2 to x392 {8,0}
  Added port Port(Some(0),0,7,List(7),List(0)) to x392 {7,0}
  Added dispatch 2 to x392 {7,0}
  Added port Port(Some(0),0,3,List(3),List(0)) to x392 {3,0}
  Added dispatch 2 to x392 {3,0}
  Added port Port(Some(0),0,5,List(5),List(0)) to x392 {5,0}
  Added dispatch 2 to x392 {5,0}
  Added port Port(Some(0),0,1,List(1),List(0)) to x392 {1,0}
  Added dispatch 2 to x392 {1,0}
  Added port Port(Some(0),0,9,List(9),List(0)) to x392 {9,0}
  Added dispatch 2 to x392 {9,0}
  Added port Port(Some(0),0,2,List(2),List(0)) to x392 {2,0}
  Added dispatch 2 to x392 {2,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x317 {0,0}
  Added dispatch 2 to x317 {0,0}
---------------------------------------------------------------------
INFERRING...
Name: r (x337)
Type: SRAM1[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:36:28
Src:  	    val r = SRAM[T](1)
Symbol:     x337 = SRAMNew(List(Const(1)),SRAM1[Fix[TRUE,_10,_22]])
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()), RegroupDims(List(0)))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 2 Reads: 
    Access: x351 {} [x358 (stage: -1)]
    Access: x362 {} [x371 (stage: -1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
  2 Read Groups:
  Group #0
    x351 = SRAMRead(x337,List(Const(0)),Set()) rd{}
       c  mod
       0    0rd
  Group #1
    x362 = SRAMRead(x337,List(Const(0)),Set(x361)) rd{}
       c  mod
       0    0rd
  Grouping 1 Writes: 
    Access: x346 {} [x347 (stage: -1)]
  1 Write Groups:
  Group #0
    x346 = SRAMWrite(x337,x345,List(Const(0)),Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x351 {}: 
      x346 {}
    x351 <-> x346: LCA: x388 (stage: -1), coarse-dist: 1
    x346 <-> x346: LCA: x347 (stage: -1), coarse-dist: <None>
  x351 <-> x346 # LCA: x388 (stage: -1), Dist: Some(1)
  x346 <-> x346 # LCA: x388 (stage: -1), Dist: Some(0)
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x351 = SRAMRead(x337,List(Const(0)),Set()) rd{}
   c  mod
   0    0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x347: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x346: SRAMWrite
    x358: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x351: SRAMRead
  **************************************************************************************
  Analyzing costs for banking schemes found for r (x337)
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.45065729457743975 (SRAM LUTs: 0.005847953216374269%, FFs: 3.6489691662105453E-4%, BRAMs: 0.4444444444444444%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 0.45065729457743975 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x351 = SRAMRead(x337,List(Const(0)),Set()) rd{}
      grp 0:    c  mod
      grp 0:    0    0rd
    Writes:
      grp 0: x346 = SRAMWrite(x337,x345,List(Const(0)),Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    2
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: x388 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x346 = SRAMWrite(x337,x345,List(Const(0)),Set()) {}
      - ProjectTemplate.scala:37:18: r(0) = (tmp(0)*tmp(0)) + (tmp(1)*tmp(1)) + (tmp(2)*tmp(2))
      - Scope: x347 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x351 = SRAMRead(x337,List(Const(0)),Set()) {}
      - ProjectTemplate.scala:44:29: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}
      - Scope: x358 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Result: Created instance #0
Group #1: 
    Preceding writes for x362 {}: 
      x346 {}
    x362 <-> x346: LCA: x388 (stage: -1), coarse-dist: 2
    x346 <-> x346: LCA: x347 (stage: -1), coarse-dist: <None>
  x362 <-> x346 # LCA: x388 (stage: -1), Dist: Some(2)
  x346 <-> x346 # LCA: x388 (stage: -1), Dist: Some(0)
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x362 = SRAMRead(x337,List(Const(0)),Set(x361)) rd{}
   c  mod
   0    0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x347: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x346: SRAMWrite
    x373: Switch (-1) [Level: InnerControl, Loop: Single, Schedule: Fork]
      x362: SRAMRead
  **************************************************************************************
  Analyzing costs for banking schemes found for r (x337)
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.6759859418661596 (SRAM LUTs: 0.008771929824561403%, FFs: 5.473453749315818E-4%, BRAMs: 0.6666666666666666%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 0.6759859418661596 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x362 = SRAMRead(x337,List(Const(0)),Set(x361)) rd{}
      grp 0:    c  mod
      grp 0:    0    0rd
    Writes:
      grp 0: x346 = SRAMWrite(x337,x345,List(Const(0)),Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    3
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: x388 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x346 = SRAMWrite(x337,x345,List(Const(0)),Set()) {}
      - ProjectTemplate.scala:37:18: r(0) = (tmp(0)*tmp(0)) + (tmp(1)*tmp(1)) + (tmp(2)*tmp(2))
      - Scope: x347 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x362 = SRAMRead(x337,List(Const(0)),Set(x361)) {}
      - ProjectTemplate.scala:44:77: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}
      - Scope: x371 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #1 with instance #0: 
    Computing overlaps: x362 = Some(SRAMRead(x337,List(Const(0)),Set(x361))) - x351 = Some(SRAMRead(x337,List(Const(0)),Set()))
    Computing overlaps: x346 = Some(SRAMWrite(x337,x345,List(Const(0)),Set())) - x346 = Some(SRAMWrite(x337,x345,List(Const(0)),Set()))
      x362 <-> x346: LCA: x388 (stage: -1), coarse-dist: 2
      x351 <-> x346: LCA: x388 (stage: -1), coarse-dist: 1
      x346 <-> x346: LCA: x347 (stage: -1), coarse-dist: <None>
      Preceding writes for x362 {}: 
        x346 {}
      Preceding writes for x351 {}: 
      x362 <-> x346: LCA: x388 (stage: -1), coarse-dist: 2
      x351 <-> x346: LCA: x388 (stage: -1), coarse-dist: 1
      x346 <-> x346: LCA: x347 (stage: -1), coarse-dist: <None>
    x362 <-> x346 # LCA: x388 (stage: -1), Dist: Some(2)
    x351 <-> x346 # LCA: x388 (stage: -1), Dist: Some(1)
    x346 <-> x346 # LCA: x388 (stage: -1), Dist: Some(0)
    solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x362 = SRAMRead(x337,List(Const(0)),Set(x361)) rd{}
   c  mod
   0    0rd, x351 = SRAMRead(x337,List(Const(0)),Set()) rd{}
   c  mod
   0    0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
    x388: OpMemReduce (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x347: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
        x346: SRAMWrite
      x358: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
        x351: SRAMRead
      x373: Switch (-1) [Level: InnerControl, Loop: Single, Schedule: Fork]
        x362: SRAMRead
    **************************************************************************************
    Analyzing costs for banking schemes found for r (x337)
    Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
      - 2 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 2 | 1 |
            - Duplicate costs 0.6759859418661596 (SRAM LUTs: 0.008771929824561403%, FFs: 5.473453749315818E-4%, BRAMs: 0.6666666666666666%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
    ***** Cost summary *****
    Cost: 0.6759859418661596 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x362 = SRAMRead(x337,List(Const(0)),Set(x361)) rd{}
        grp 0:    c  mod
        grp 0:    0    0rd
        grp 2: x351 = SRAMRead(x337,List(Const(0)),Set()) rd{}
        grp 2:    c  mod
        grp 2:    0    0rd
      Writes:
        grp 0: x346 = SRAMWrite(x337,x345,List(Const(0)),Set()) wr{}
        grp 0:    c  mod
        grp 0:    0    0wr
      Result: Right(List(<Banked>
Depth:    3
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: x388 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x346 = SRAMWrite(x337,x345,List(Const(0)),Set()) {}
      - ProjectTemplate.scala:37:18: r(0) = (tmp(0)*tmp(0)) + (tmp(1)*tmp(1)) + (tmp(2)*tmp(2))
      - Scope: x347 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x351 = SRAMRead(x337,List(Const(0)),Set()) {}
      - ProjectTemplate.scala:44:29: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}
      - Scope: x358 (scope: 0, 0)
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x362 = SRAMRead(x337,List(Const(0)),Set(x361)) {}
      - ProjectTemplate.scala:44:77: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}
      - Scope: x371 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Result: Merged 1 into instance 0
---------------------------------------------------------------------
SUMMARY: 
Name: r (x337)
Type: SRAM1[Fix[TRUE,_10,_22]]
Src:  ProjectTemplate.scala:36:28
Src:  	    val r = SRAM[T](1)
Symbol:     x337 = SRAMNew(List(Const(1)),SRAM1[Fix[TRUE,_10,_22]])
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    3
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: x388 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x346 = SRAMWrite(x337,x345,List(Const(0)),Set()) {}
        - ProjectTemplate.scala:37:18: r(0) = (tmp(0)*tmp(0)) + (tmp(1)*tmp(1)) + (tmp(2)*tmp(2))
        - Scope: x347 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x351 = SRAMRead(x337,List(Const(0)),Set()) {}
        - ProjectTemplate.scala:44:29: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}
        - Scope: x358 (scope: 0, 0)
  2 [Type:WR]:
  2 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x362 = SRAMRead(x337,List(Const(0)),Set(x361)) {}
        - ProjectTemplate.scala:44:77: force(0) = if (r(0) > 0.to[T] && r(0) > 1.to[T]) {((100.to[T])/r(0)/r(0)/r(0)/r(0)/r(0))-((10.to[T])/r(0)/r(0))} else {90.to[T]}
        - Scope: x371 (scope: 0, 0)
  M [Type:WR]:
  M [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(2),0,0,List(0),List(0)) to x362 {}
  Added dispatch 0 to x362 {}
  Added port Port(Some(1),0,0,List(0),List(0)) to x351 {}
  Added dispatch 0 to x351 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x346 {}
  Added dispatch 0 to x346 {}
  Added port Port(Some(2),0,0,List(0),List(0)) to x362 {}
  Added dispatch 0 to x362 {}
  Added port Port(Some(1),0,0,List(0),List(0)) to x351 {}
  Added dispatch 0 to x351 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x346 {}
  Added dispatch 0 to x346 {}
x403 completed in: 2 ms
x298 completed in: 2 ms
x296 completed in: 2 ms
x402 completed in: 2 ms
x350 completed in: 2 ms
x271 completed in: 2 ms
x399 completed in: 2 ms
x397 completed in: 3 ms
x297 completed in: 3 ms
x398 completed in: 3 ms
x270 completed in: 7 ms
x348 completed in: 8 ms
x324 completed in: 8 ms
x337 completed in: 10 ms
x404 completed in: 15 ms
x349 completed in: 15 ms
x329 completed in: 68 ms
x269 completed in: 87 ms
x321 completed in: 386 ms
x268 completed in: 1110 ms
